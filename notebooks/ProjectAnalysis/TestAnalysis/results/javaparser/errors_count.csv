error,count
"Index: 1, Size: 1",4
,1415
com.github.javaparser.ast.type.UnknownType,1
com.sun.proxy.$Proxy4 cannot be cast to me.tomassetti.symbolsolver.model.declarations.ValueDeclaration,1
me.tomassetti.symbolsolver.model.javassist.JavassistClassDeclaration cannot be cast to me.tomassetti.symbolsolver.model.declarations.ValueDeclaration,1
Find parameters of ReflectionClassDeclaration{clazz=java.util.function.Predicate} in ( t)-&gt;t.isEmpty(),2
me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext,1
com.github.javaparser.ast.body.TypeDeclaration,28
We should find how to discriminate between these candidates,1
src/test/resources/junit-4.8.1.jar (No such file or directory),395
Method cannot be resolved overloaded,2
"Unexpected exception, expected&lt;me.tomassetti.symbolsolver.model.declarations.AmbiguityException&gt; but was&lt;java.lang.StackOverflowError&gt;",2
"Unexpected exception, expected&lt;me.tomassetti.symbolsolver.model.declarations.MethodAmbiguityException&gt; but was&lt;java.lang.NullPointerException&gt;",2
Method &#x27;add&#x27; cannot be resolved in context commentsInsideChild.add(c) (line: 44) me.tomassetti.symbolsolver.model.javaparser.contexts.MethodCallExprContext@fb7ee24f,1
"Method &#x27;accept&#x27; cannot be resolved in context n1.accept(this, n2) (line: 12) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@4b5423e",9
"Method &#x27;accept&#x27; cannot be resolved in context javadocComment.accept(this, arg) (line: 35) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@321a340",3
"Unsolved symbol in JavaParserClassDeclaration{wrappedNode=public final class PositionUtils {      private  PositionUtils() {     // prevent instantiation     }      public static &lt;T extends Node&gt; void sortByBeginPosition(List&lt;T&gt; nodes) {         sortByBeginPosition(nodes, false);     }      public static &lt;T extends Node&gt; void sortByBeginPosition(List&lt;T&gt; nodes, final boolean ignoringAnnotations) {         Collections.sort(nodes, new Comparator&lt;Node&gt;() {              @Override             public int compare(Node o1, Node o2) {                 return PositionUtils.compare(o1, o2, ignoringAnnotations);             }         });     }      public static boolean areInOrder(Node a, Node b) {         return areInOrder(a, b, false);     }      public static boolean areInOrder(Node a, Node b, boolean ignoringAnnotations) {         return compare(a, b, ignoringAnnotations) &lt;= 0;     }      private static int compare(Node a, Node b, boolean ignoringAnnotations) {         if (ignoringAnnotations) {             int signLine = signum(beginLineWithoutConsideringAnnotation(a) - beginLineWithoutConsideringAnnotation(b));             if (signLine == 0) {                 return signum(beginColumnWithoutConsideringAnnotation(a) - beginColumnWithoutConsideringAnnotation(b));             } else {                 return signLine;             }         }         int signLine = signum(a.getBeginLine() - b.getBeginLine());         if (signLine == 0) {             return signum(a.getBeginColumn() - b.getBeginColumn());         } else {             return signLine;         }     }      public static AnnotationExpr getLastAnnotation(Node node) {         if (node instanceof AnnotableNode) {             List&lt;AnnotationExpr&gt; annotations = new LinkedList&lt;AnnotationExpr&gt;();             annotations.addAll(((AnnotableNode) node).getAnnotations());             if (annotations.size() == 0) {                 return null;             }             sortByBeginPosition(annotations);             return annotations.get(annotations.size() - 1);         } else {             return null;         }     }      private static int beginLineWithoutConsideringAnnotation(Node node) {         return beginNodeWithoutConsideringAnnotations(node).getBeginLine();     }      private static int beginColumnWithoutConsideringAnnotation(Node node) {         return beginNodeWithoutConsideringAnnotations(node).getBeginColumn();     }      private static Node beginNodeWithoutConsideringAnnotations(Node node) {         if (node instanceof MethodDeclaration) {             MethodDeclaration casted = (MethodDeclaration) node;             return casted.getType();         } else if (node instanceof FieldDeclaration) {             FieldDeclaration casted = (FieldDeclaration) node;             return casted.getType();         } else if (node instanceof ClassOrInterfaceDeclaration) {             ClassOrInterfaceDeclaration casted = (ClassOrInterfaceDeclaration) node;             return casted.getNameExpr();         } else {             return node;         }     }      public static boolean nodeContains(Node container, Node contained, boolean ignoringAnnotations) {         if (!ignoringAnnotations || PositionUtils.getLastAnnotation(container) == null) {             return container.contains(contained);         }         if (!container.contains(contained)) {             return false;         }         // let&#x27;s not consider it contained         if (container instanceof AnnotableNode) {             int bl = beginLineWithoutConsideringAnnotation(container);             int bc = beginColumnWithoutConsideringAnnotation(container);             if (bl &gt; contained.getBeginLine())                 return false;             if (bl == contained.getBeginLine() &amp;&amp; bc &gt; contained.getBeginColumn())                 return false;             if (container.getEndLine() &lt; contained.getEndLine())                 return false;             if (container.getEndLine() == contained.getEndLine() &amp;&amp; container.getEndColumn() &lt; contained.getEndColumn())                 return false;             return true;         }         return true;     } }} : Method &#x27;sortByBeginPosition&#x27; with parameterTypes [ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.List}, typeParameters=[ReferenceTypeUsage{declaration=JavaParserClassDeclaration{wrappedNode=/**  * Abstract class for all AST nodes that represent comments.  *   * @see BlockComment  * @see LineComment  * @see JavadocComment  * @author Julio Vilmar Gesser  */ public abstract class Comment extends Node {      private String content;      private Node commentedNode;      public  Comment() {     }      public  Comment(String content) {         this.content = content;     }      public  Comment(int beginLine, int beginColumn, int endLine, int endColumn, String content) {         super(beginLine, beginColumn, endLine, endColumn);         this.content = content;     }      /**      * Return the text of the comment.      *       * @return text of the comment      */     public final String getContent() {         return content;     }      /**      * Sets the text of the comment.      *       * @param content      *            the text of the comment to set      */     public void setContent(String content) {         this.content = content;     }      public boolean isLineComment() {         return false;     }      public LineComment asLineComment() {         if (isLineComment()) {             return (LineComment) this;         } else {             throw new UnsupportedOperationException(&quot;Not a line comment&quot;);         }     }      public Node getCommentedNode() {         return this.commentedNode;     }      public void setCommentedNode(Node commentedNode) {         if (commentedNode == null) {             this.commentedNode = commentedNode;             return;         }         if (commentedNode == this) {             throw new IllegalArgumentException();         }         if (commentedNode instanceof Comment) {             throw new IllegalArgumentException();         }         this.commentedNode = commentedNode;     }      public boolean isOrphan() {         return this.commentedNode == null;     } }}, typeParameters=[]}]}]",4
Method &#x27;setAsParentNodeOf&#x27; cannot be resolved in context setAsParentNodeOf(this.stmts) (line: 65) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@b3d2e09d,2
Method &#x27;setAsParentNodeOf&#x27; cannot be resolved in context setAsParentNodeOf(this.typeArgs) (line: 102) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@672ef6b3,2
"Method &#x27;sortByBeginPosition&#x27; cannot be resolved in context sortByBeginPosition(nodes, false) (line: 46) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@83430e00",3
Method &#x27;setAsParentNodeOf&#x27; cannot be resolved in context setAsParentNodeOf(this.typeArgs) (line: 96) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@672ef6b3,2
"Method &#x27;accept&#x27; cannot be resolved in context n1.accept(this, n2) (line: 142) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@4b5423e",4
Method &#x27;setAsParentNodeOf&#x27; cannot be resolved in context setAsParentNodeOf(this.entries) (line: 82) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@2ab97698,2
"Unsolved symbol in ReflectionClassDeclaration{clazz=java.util.Collections} : Method &#x27;sort&#x27; with parameterTypes [ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.List}, typeParameters=[TypeUsageOfTypeParameter{typeParameter=me.tomassetti.symbolsolver.resolution.javaparser.declarations.JavaParserTypeParameter@cb2a34c3}]}, ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.Comparator}, typeParameters=[ReferenceTypeUsage{declaration=JavaParserClassDeclaration{wrappedNode=/**  * Abstract class for all nodes of the AST.  *  * Each Node can have one associated comment which describe it and  * a number of &quot;orphan comments&quot; which it contains but are not specifically  * associated to any element.  *   * @author Julio Vilmar Gesser  */ public abstract class Node implements Cloneable {      private int beginLine;      private int beginColumn;      private int endLine;      private int endColumn;      private Node parentNode;      private List&lt;Node&gt; childrenNodes = new LinkedList&lt;Node&gt;();      private List&lt;Comment&gt; orphanComments = new LinkedList&lt;Comment&gt;();      /**      * This attribute can store additional information from semantic analysis.      */     private Object data;      private Comment comment;      public  Node() {     }      public  Node(final int beginLine, final int beginColumn, final int endLine, final int endColumn) {         this.beginLine = beginLine;         this.beginColumn = beginColumn;         this.endLine = endLine;         this.endColumn = endColumn;     }      /**      * Accept method for visitor support.      *       * @param &lt;R&gt;      *            the type the return value of the visitor      * @param &lt;A&gt;      *            the type the argument passed to the visitor      * @param v      *            the visitor implementation      * @param arg      *            the argument passed to the visitor      * @return the result of the visit      */     public abstract &lt;R, A&gt; R accept(GenericVisitor&lt;R, A&gt; v, A arg);      /**      * Accept method for visitor support.      *       * @param &lt;A&gt;      *            the type the argument passed for the visitor      * @param v      *            the visitor implementation      * @param arg      *            any value relevant for the visitor      */     public abstract &lt;A&gt; void accept(VoidVisitor&lt;A&gt; v, A arg);      /**      * Return the begin column of this node.      *       * @return the begin column of this node      */     public final int getBeginColumn() {         return beginColumn;     }      /**      * Return the begin line of this node.      *       * @return the begin line of this node      */     public final int getBeginLine() {         return beginLine;     }      /**      * This is a comment associated with this node.      *      * @return comment property      */     public final Comment getComment() {         return comment;     }      /**      * Use this to retrieve additional information associated to this node.      *      * @return data property      */     public final Object getData() {         return data;     }      /**      * Return the end column of this node.      *       * @return the end column of this node      */     public final int getEndColumn() {         return endColumn;     }      /**      * Return the end line of this node.      *       * @return the end line of this node      */     public final int getEndLine() {         return endLine;     }      /**      * Sets the begin column of this node.      *       * @param beginColumn      *            the begin column of this node      */     public final void setBeginColumn(final int beginColumn) {         this.beginColumn = beginColumn;     }      /**      * Sets the begin line of this node.      *       * @param beginLine      *            the begin line of this node      */     public final void setBeginLine(final int beginLine) {         this.beginLine = beginLine;     }      /**      * Use this to store additional information to this node.      *      * @param comment to be set      */     public final void setComment(final Comment comment) {         if (comment != null &amp;&amp; (this instanceof Comment)) {             throw new RuntimeException(&quot;A comment can not be commented&quot;);         }         if (this.comment != null) {             this.comment.setCommentedNode(null);         }         this.comment = comment;         if (comment != null) {             this.comment.setCommentedNode(this);         }     }      /**      * Use this to store additional information to this node.      *      * @param data to be set      */     public final void setData(final Object data) {         this.data = data;     }      /**      * Sets the end column of this node.      *       * @param endColumn      *            the end column of this node      */     public final void setEndColumn(final int endColumn) {         this.endColumn = endColumn;     }      /**      * Sets the end line of this node.      *       * @param endLine      *            the end line of this node      */     public final void setEndLine(final int endLine) {         this.endLine = endLine;     }      /**      * Return the String representation of this node.      *       * @return the String representation of this node      */     @Override     public final String toString() {         final DumpVisitor visitor = new DumpVisitor();         accept(visitor, null);         return visitor.getSource();     }      public final String toStringWithoutComments() {         final DumpVisitor visitor = new DumpVisitor(false);         accept(visitor, null);         return visitor.getSource();     }      @Override     public final int hashCode() {         return toString().hashCode();     }      @Override     public boolean equals(final Object obj) {         if (obj == null || !(obj instanceof Node)) {             return false;         }         return EqualsVisitor.equals(this, (Node) obj);     }      @Override     public Node clone() {         return this.accept(new CloneVisitor(), null);     }      public Node getParentNode() {         return parentNode;     }      public List&lt;Node&gt; getChildrenNodes() {         return childrenNodes;     }      public boolean contains(Node other) {         if (getBeginLine() &gt; other.getBeginLine())             return false;         if (getBeginLine() == other.getBeginLine() &amp;&amp; getBeginColumn() &gt; other.getBeginColumn())             return false;         if (getEndLine() &lt; other.getEndLine())             return false;         if (getEndLine() == other.getEndLine() &amp;&amp; getEndColumn() &lt; other.getEndColumn())             return false;         return true;     }      public void addOrphanComment(Comment comment) {         orphanComments.add(comment);         comment.setParentNode(this);     }      /**      * This is a list of Comment which are inside the node and are not associated      * with any meaningful AST Node.      *      * For example, comments at the end of methods (immediately before the parenthesis)      * or at the end of CompilationUnit are orphan comments.      *      * When more than one comments preceed a statement, the one immediately preceeding it      * it is associated with the statements, while the others are &quot;orphan&quot;.      * @return all comments that cannot be attributed to a concept      */     public List&lt;Comment&gt; getOrphanComments() {         return orphanComments;     }      /**      * This is the list of Comment which are contained in the Node either because      * they are properly associated to one of its children or because they are floating      * around inside the Node      * @return all Comments within the node as a list      */     public List&lt;Comment&gt; getAllContainedComments() {         List&lt;Comment&gt; comments = new LinkedList&lt;Comment&gt;();         comments.addAll(getOrphanComments());         for (Node child : getChildrenNodes()) {             if (child.getComment() != null) {                 comments.add(child.getComment());             }             comments.addAll(child.getAllContainedComments());         }         return comments;     }      /**      * Assign a new parent to this node, removing it      * from the list of children of the previous parent, if any.      *      * @param parentNode node to be set as parent      */     public void setParentNode(Node parentNode) {         // remove from old parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.remove(this);         }         this.parentNode = parentNode;         // add to new parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.add(this);         }     }      protected void setAsParentNodeOf(List&lt;? extends Node&gt; childNodes) {         if (childNodes != null) {             Iterator&lt;? extends Node&gt; it = childNodes.iterator();             while (it.hasNext()) {                 Node current = it.next();                 current.setParentNode(this);             }         }     }      protected void setAsParentNodeOf(Node childNode) {         if (childNode != null) {             childNode.setParentNode(this);         }     }      public static final int ABSOLUTE_BEGIN_LINE = -1;      public static final int ABSOLUTE_END_LINE = -2;      public boolean isPositionedAfter(int line, int column) {         if (line == ABSOLUTE_BEGIN_LINE)             return true;         if (getBeginLine() &gt; line) {             return true;         } else if (getBeginLine() == line) {             return getBeginColumn() &gt; column;         } else {             return false;         }     }      public boolean isPositionedBefore(int line, int column) {         if (line == ABSOLUTE_END_LINE)             return true;         if (getEndLine() &lt; line) {             return true;         } else if (getEndLine() == line) {             return getEndColumn() &lt; column;         } else {             return false;         }     }      public boolean hasComment() {         return comment != null;     } }}, typeParameters=[]}]}]",1
Method &#x27;addAll&#x27; cannot be resolved in context children.addAll(node.getChildrenNodes()) (line: 337) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@6e12ea99,1
Method &#x27;addAll&#x27; cannot be resolved in context annotations.addAll(((AnnotableNode) node).getAnnotations()) (line: 87) me.tomassetti.symbolsolver.resolution.javaparser.contexts.MethodCallExprContext@1a0bf358,1
Method &#x27;addAll&#x27; cannot be resolved in context children.addAll(node.getChildrenNodes()) (line: 337) MethodCallExprContext{},2
Method &#x27;addAll&#x27; cannot be resolved in context comments.addAll(lineComments) (line: 75) MethodCallExprContext{},3
Method &#x27;addAll&#x27; cannot be resolved in context annotations.addAll(((AnnotableNode) node).getAnnotations()) (line: 87) MethodCallExprContext{},2
"Ambiguous method call: cannot find a most applicable method: MethodUsage{declaration=ReflectionMethodDeclaration{method=public java.lang.AbstractStringBuilder java.lang.AbstractStringBuilder.append(java.lang.CharSequence)}, paramTypes=[ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.lang.CharSequence}, typeParameters=[]}]}, MethodUsage{declaration=ReflectionMethodDeclaration{method=public java.lang.AbstractStringBuilder java.lang.AbstractStringBuilder.append(java.lang.Object)}, paramTypes=[ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.lang.Object}, typeParameters=[]}]}. First declared in java.lang.AbstractStringBuilder",8
Method &#x27;addAll&#x27; cannot be resolved in context children.addAll(node.getChildrenNodes()) (line: 10) MethodCallExprContext{},1
Method &#x27;addAll&#x27; cannot be resolved in context childrenAndComments.addAll(commentsToAttribute) (line: 404) MethodCallExprContext{},1
src/test/resources/javaparser-core-2.1.0.jar (No such file or directory),20
me.tomassetti.symbolsolver.model.typesystem.ReferenceTypeUsageImpl,2
me.tomassetti.symbolsolver.model.typesystem.PrimitiveTypeUsage,1
"Encountered &quot; &quot;&amp;&quot; &quot;&amp; &quot;&quot; at line 4, column 38. Was expecting one of:     &quot;boolean&quot; ...     &quot;byte&quot; ...     &quot;char&quot; ...     &quot;double&quot; ...     &quot;false&quot; ...     &quot;float&quot; ...     &quot;int&quot; ...     &quot;long&quot; ...     &quot;new&quot; ...     &quot;null&quot; ...     &quot;short&quot; ...     &quot;super&quot; ...     &quot;this&quot; ...     &quot;true&quot; ...     &quot;void&quot; ...     &lt;LONG_LITERAL&gt; ...     &lt;INTEGER_LITERAL&gt; ...     &lt;FLOATING_POINT_LITERAL&gt; ...     &lt;CHARACTER_LITERAL&gt; ...     &lt;STRING_LITERAL&gt; ...     &lt;IDENTIFIER&gt; ...     &quot;(&quot; ...     &quot;!&quot; ...     &quot;~&quot; ...     &quot;++&quot; ...     &quot;--&quot; ...     &quot;+&quot; ...     &quot;-&quot; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     ",2
"Encountered &quot; &quot;&amp;&quot; &quot;&amp; &quot;&quot; at line 3, column 49. Was expecting one of:     &quot;boolean&quot; ...     &quot;byte&quot; ...     &quot;char&quot; ...     &quot;double&quot; ...     &quot;false&quot; ...     &quot;float&quot; ...     &quot;int&quot; ...     &quot;long&quot; ...     &quot;new&quot; ...     &quot;null&quot; ...     &quot;short&quot; ...     &quot;super&quot; ...     &quot;this&quot; ...     &quot;true&quot; ...     &quot;void&quot; ...     &lt;LONG_LITERAL&gt; ...     &lt;INTEGER_LITERAL&gt; ...     &lt;FLOATING_POINT_LITERAL&gt; ...     &lt;CHARACTER_LITERAL&gt; ...     &lt;STRING_LITERAL&gt; ...     &lt;IDENTIFIER&gt; ...     &quot;(&quot; ...     &quot;!&quot; ...     &quot;~&quot; ...     &quot;++&quot; ...     &quot;--&quot; ...     &quot;+&quot; ...     &quot;-&quot; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     &lt;IDENTIFIER&gt; ...     ",1
Step is pending!,4
com.github.javaparser.ast.type.ReferenceType cannot be cast to com.github.javaparser.ast.expr.NameExpr,8
"Index: 2, Size: 0",9
com.github.javaparser.ast.expr.NameExpr cannot be cast to com.github.javaparser.ast.expr.MethodReferenceExpr,2
charsetName,69
Empty import declarations have no name,7
com.github.javaparser.ast.TypeParameter cannot be cast to [I,3
Failed to parse lambda expression! Please create an issue at https://github.com/javaparser/javaparser/issues,1
"Unsolved symbol in ReflectionClassDeclaration{clazz=java.util.Arrays} : Method &#x27;asList&#x27; with parameterTypes [ArrayTypeUsage{baseType=ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.lang.Long}, typeParameters=[]}}]",1
"Method &#x27;nodeEquals&#x27; cannot be resolved in context SINGLETON.nodeEquals(n1, n2) (line: 83) MethodCallExprContext{wrapped=SINGLETON.nodeEquals(n1, n2)}. Parameter types: [ReferenceTypeUsage{declaration=JavaParserClassDeclaration{wrappedNode=/**  * Abstract class for all nodes of the AST.  *  * Each Node can have one associated comment which describe it and  * a number of &quot;orphan comments&quot; which it contains but are not specifically  * associated to any element.  *   * @author Julio Vilmar Gesser  */ public abstract class Node implements Cloneable {      private int beginLine;      private int beginColumn;      private int endLine;      private int endColumn;      private Node parentNode;      private List&lt;Node&gt; childrenNodes = new LinkedList&lt;Node&gt;();      private List&lt;Comment&gt; orphanComments = new LinkedList&lt;Comment&gt;();      /**      * This attribute can store additional information from semantic analysis.      */     private Object data;      private Comment comment;      public Node() {     }      public Node(final int beginLine, final int beginColumn, final int endLine, final int endColumn) {         this.beginLine = beginLine;         this.beginColumn = beginColumn;         this.endLine = endLine;         this.endColumn = endColumn;     }      /**      * Accept method for visitor support.      *       * @param &lt;R&gt;      *            the type the return value of the visitor      * @param &lt;A&gt;      *            the type the argument passed to the visitor      * @param v      *            the visitor implementation      * @param arg      *            the argument passed to the visitor      * @return the result of the visit      */     public abstract &lt;R, A&gt; R accept(GenericVisitor&lt;R, A&gt; v, A arg);      /**      * Accept method for visitor support.      *       * @param &lt;A&gt;      *            the type the argument passed for the visitor      * @param v      *            the visitor implementation      * @param arg      *            any value relevant for the visitor      */     public abstract &lt;A&gt; void accept(VoidVisitor&lt;A&gt; v, A arg);      /**      * Return the begin column of this node.      *       * @return the begin column of this node      */     public final int getBeginColumn() {         return beginColumn;     }      /**      * Return the begin line of this node.      *       * @return the begin line of this node      */     public final int getBeginLine() {         return beginLine;     }      /**      * This is a comment associated with this node.      *      * @return comment property      */     public final Comment getComment() {         return comment;     }      /**      * Use this to retrieve additional information associated to this node.      *      * @return data property      */     public final Object getData() {         return data;     }      /**      * Return the end column of this node.      *       * @return the end column of this node      */     public final int getEndColumn() {         return endColumn;     }      /**      * Return the end line of this node.      *       * @return the end line of this node      */     public final int getEndLine() {         return endLine;     }      /**      * Sets the begin column of this node.      *       * @param beginColumn      *            the begin column of this node      */     public final void setBeginColumn(final int beginColumn) {         this.beginColumn = beginColumn;     }      /**      * Sets the begin line of this node.      *       * @param beginLine      *            the begin line of this node      */     public final void setBeginLine(final int beginLine) {         this.beginLine = beginLine;     }      /**      * Use this to store additional information to this node.      *      * @param comment to be set      */     public final void setComment(final Comment comment) {         if (comment != null &amp;&amp; (this instanceof Comment)) {             throw new RuntimeException(&quot;A comment can not be commented&quot;);         }         if (this.comment != null) {             this.comment.setCommentedNode(null);         }         this.comment = comment;         if (comment != null) {             this.comment.setCommentedNode(this);         }     }      /**      * Use this to store additional information to this node.      *      * @param data to be set      */     public final void setData(final Object data) {         this.data = data;     }      /**      * Sets the end column of this node.      *       * @param endColumn      *            the end column of this node      */     public final void setEndColumn(final int endColumn) {         this.endColumn = endColumn;     }      /**      * Sets the end line of this node.      *       * @param endLine      *            the end line of this node      */     public final void setEndLine(final int endLine) {         this.endLine = endLine;     }      /**      * Return the String representation of this node.      *       * @return the String representation of this node      */     @Override     public final String toString() {         final DumpVisitor visitor = new DumpVisitor();         accept(visitor, null);         return visitor.getSource();     }      public final String toStringWithoutComments() {         final DumpVisitor visitor = new DumpVisitor(false);         accept(visitor, null);         return visitor.getSource();     }      @Override     public final int hashCode() {         return toString().hashCode();     }      @Override     public boolean equals(final Object obj) {         if (obj == null || !(obj instanceof Node)) {             return false;         }         return EqualsVisitor.equals(this, (Node) obj);     }      @Override     public Node clone() {         return this.accept(new CloneVisitor(), null);     }      public Node getParentNode() {         return parentNode;     }      public List&lt;Node&gt; getChildrenNodes() {         return childrenNodes;     }      public boolean contains(Node other) {         if (getBeginLine() &gt; other.getBeginLine())             return false;         if (getBeginLine() == other.getBeginLine() &amp;&amp; getBeginColumn() &gt; other.getBeginColumn())             return false;         if (getEndLine() &lt; other.getEndLine())             return false;         if (getEndLine() == other.getEndLine() &amp;&amp; getEndColumn() &lt; other.getEndColumn())             return false;         return true;     }      public void addOrphanComment(Comment comment) {         orphanComments.add(comment);         comment.setParentNode(this);     }      /**      * This is a list of Comment which are inside the node and are not associated      * with any meaningful AST Node.      *      * For example, comments at the end of methods (immediately before the parenthesis)      * or at the end of CompilationUnit are orphan comments.      *      * When more than one comments preceed a statement, the one immediately preceeding it      * it is associated with the statements, while the others are &quot;orphan&quot;.      * @return all comments that cannot be attributed to a concept      */     public List&lt;Comment&gt; getOrphanComments() {         return orphanComments;     }      /**      * This is the list of Comment which are contained in the Node either because      * they are properly associated to one of its children or because they are floating      * around inside the Node      * @return all Comments within the node as a list      */     public List&lt;Comment&gt; getAllContainedComments() {         List&lt;Comment&gt; comments = new LinkedList&lt;Comment&gt;();         comments.addAll(getOrphanComments());         for (Node child : getChildrenNodes()) {             if (child.getComment() != null) {                 comments.add(child.getComment());             }             comments.addAll(child.getAllContainedComments());         }         return comments;     }      /**      * Assign a new parent to this node, removing it      * from the list of children of the previous parent, if any.      *      * @param parentNode node to be set as parent      */     public void setParentNode(Node parentNode) {         // remove from old parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.remove(this);         }         this.parentNode = parentNode;         // add to new parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.add(this);         }     }      protected void setAsParentNodeOf(List&lt;? extends Node&gt; childNodes) {         if (childNodes != null) {             Iterator&lt;? extends Node&gt; it = childNodes.iterator();             while (it.hasNext()) {                 Node current = it.next();                 current.setParentNode(this);             }         }     }      protected void setAsParentNodeOf(Node childNode) {         if (childNode != null) {             childNode.setParentNode(this);         }     }      public static final int ABSOLUTE_BEGIN_LINE = -1;      public static final int ABSOLUTE_END_LINE = -2;      public boolean isPositionedAfter(int line, int column) {         if (line == ABSOLUTE_BEGIN_LINE)             return true;         if (getBeginLine() &gt; line) {             return true;         } else if (getBeginLine() == line) {             return getBeginColumn() &gt; column;         } else {             return false;         }     }      public boolean isPositionedBefore(int line, int column) {         if (line == ABSOLUTE_END_LINE)             return true;         if (getEndLine() &lt; line) {             return true;         } else if (getEndLine() == line) {             return getEndColumn() &lt; column;         } else {             return false;         }     }      public boolean hasComment() {         return comment != null;     } }}, typeParameters=[]}, ReferenceTypeUsage{declaration=JavaParserClassDeclaration{wrappedNode=/**  * Abstract class for all nodes of the AST.  *  * Each Node can have one associated comment which describe it and  * a number of &quot;orphan comments&quot; which it contains but are not specifically  * associated to any element.  *   * @author Julio Vilmar Gesser  */ public abstract class Node implements Cloneable {      private int beginLine;      private int beginColumn;      private int endLine;      private int endColumn;      private Node parentNode;      private List&lt;Node&gt; childrenNodes = new LinkedList&lt;Node&gt;();      private List&lt;Comment&gt; orphanComments = new LinkedList&lt;Comment&gt;();      /**      * This attribute can store additional information from semantic analysis.      */     private Object data;      private Comment comment;      public Node() {     }      public Node(final int beginLine, final int beginColumn, final int endLine, final int endColumn) {         this.beginLine = beginLine;         this.beginColumn = beginColumn;         this.endLine = endLine;         this.endColumn = endColumn;     }      /**      * Accept method for visitor support.      *       * @param &lt;R&gt;      *            the type the return value of the visitor      * @param &lt;A&gt;      *            the type the argument passed to the visitor      * @param v      *            the visitor implementation      * @param arg      *            the argument passed to the visitor      * @return the result of the visit      */     public abstract &lt;R, A&gt; R accept(GenericVisitor&lt;R, A&gt; v, A arg);      /**      * Accept method for visitor support.      *       * @param &lt;A&gt;      *            the type the argument passed for the visitor      * @param v      *            the visitor implementation      * @param arg      *            any value relevant for the visitor      */     public abstract &lt;A&gt; void accept(VoidVisitor&lt;A&gt; v, A arg);      /**      * Return the begin column of this node.      *       * @return the begin column of this node      */     public final int getBeginColumn() {         return beginColumn;     }      /**      * Return the begin line of this node.      *       * @return the begin line of this node      */     public final int getBeginLine() {         return beginLine;     }      /**      * This is a comment associated with this node.      *      * @return comment property      */     public final Comment getComment() {         return comment;     }      /**      * Use this to retrieve additional information associated to this node.      *      * @return data property      */     public final Object getData() {         return data;     }      /**      * Return the end column of this node.      *       * @return the end column of this node      */     public final int getEndColumn() {         return endColumn;     }      /**      * Return the end line of this node.      *       * @return the end line of this node      */     public final int getEndLine() {         return endLine;     }      /**      * Sets the begin column of this node.      *       * @param beginColumn      *            the begin column of this node      */     public final void setBeginColumn(final int beginColumn) {         this.beginColumn = beginColumn;     }      /**      * Sets the begin line of this node.      *       * @param beginLine      *            the begin line of this node      */     public final void setBeginLine(final int beginLine) {         this.beginLine = beginLine;     }      /**      * Use this to store additional information to this node.      *      * @param comment to be set      */     public final void setComment(final Comment comment) {         if (comment != null &amp;&amp; (this instanceof Comment)) {             throw new RuntimeException(&quot;A comment can not be commented&quot;);         }         if (this.comment != null) {             this.comment.setCommentedNode(null);         }         this.comment = comment;         if (comment != null) {             this.comment.setCommentedNode(this);         }     }      /**      * Use this to store additional information to this node.      *      * @param data to be set      */     public final void setData(final Object data) {         this.data = data;     }      /**      * Sets the end column of this node.      *       * @param endColumn      *            the end column of this node      */     public final void setEndColumn(final int endColumn) {         this.endColumn = endColumn;     }      /**      * Sets the end line of this node.      *       * @param endLine      *            the end line of this node      */     public final void setEndLine(final int endLine) {         this.endLine = endLine;     }      /**      * Return the String representation of this node.      *       * @return the String representation of this node      */     @Override     public final String toString() {         final DumpVisitor visitor = new DumpVisitor();         accept(visitor, null);         return visitor.getSource();     }      public final String toStringWithoutComments() {         final DumpVisitor visitor = new DumpVisitor(false);         accept(visitor, null);         return visitor.getSource();     }      @Override     public final int hashCode() {         return toString().hashCode();     }      @Override     public boolean equals(final Object obj) {         if (obj == null || !(obj instanceof Node)) {             return false;         }         return EqualsVisitor.equals(this, (Node) obj);     }      @Override     public Node clone() {         return this.accept(new CloneVisitor(), null);     }      public Node getParentNode() {         return parentNode;     }      public List&lt;Node&gt; getChildrenNodes() {         return childrenNodes;     }      public boolean contains(Node other) {         if (getBeginLine() &gt; other.getBeginLine())             return false;         if (getBeginLine() == other.getBeginLine() &amp;&amp; getBeginColumn() &gt; other.getBeginColumn())             return false;         if (getEndLine() &lt; other.getEndLine())             return false;         if (getEndLine() == other.getEndLine() &amp;&amp; getEndColumn() &lt; other.getEndColumn())             return false;         return true;     }      public void addOrphanComment(Comment comment) {         orphanComments.add(comment);         comment.setParentNode(this);     }      /**      * This is a list of Comment which are inside the node and are not associated      * with any meaningful AST Node.      *      * For example, comments at the end of methods (immediately before the parenthesis)      * or at the end of CompilationUnit are orphan comments.      *      * When more than one comments preceed a statement, the one immediately preceeding it      * it is associated with the statements, while the others are &quot;orphan&quot;.      * @return all comments that cannot be attributed to a concept      */     public List&lt;Comment&gt; getOrphanComments() {         return orphanComments;     }      /**      * This is the list of Comment which are contained in the Node either because      * they are properly associated to one of its children or because they are floating      * around inside the Node      * @return all Comments within the node as a list      */     public List&lt;Comment&gt; getAllContainedComments() {         List&lt;Comment&gt; comments = new LinkedList&lt;Comment&gt;();         comments.addAll(getOrphanComments());         for (Node child : getChildrenNodes()) {             if (child.getComment() != null) {                 comments.add(child.getComment());             }             comments.addAll(child.getAllContainedComments());         }         return comments;     }      /**      * Assign a new parent to this node, removing it      * from the list of children of the previous parent, if any.      *      * @param parentNode node to be set as parent      */     public void setParentNode(Node parentNode) {         // remove from old parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.remove(this);         }         this.parentNode = parentNode;         // add to new parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.add(this);         }     }      protected void setAsParentNodeOf(List&lt;? extends Node&gt; childNodes) {         if (childNodes != null) {             Iterator&lt;? extends Node&gt; it = childNodes.iterator();             while (it.hasNext()) {                 Node current = it.next();                 current.setParentNode(this);             }         }     }      protected void setAsParentNodeOf(Node childNode) {         if (childNode != null) {             childNode.setParentNode(this);         }     }      public static final int ABSOLUTE_BEGIN_LINE = -1;      public static final int ABSOLUTE_END_LINE = -2;      public boolean isPositionedAfter(int line, int column) {         if (line == ABSOLUTE_BEGIN_LINE)             return true;         if (getBeginLine() &gt; line) {             return true;         } else if (getBeginLine() == line) {             return getBeginColumn() &gt; column;         } else {             return false;         }     }      public boolean isPositionedBefore(int line, int column) {         if (line == ABSOLUTE_END_LINE)             return true;         if (getEndLine() &lt; line) {             return true;         } else if (getEndLine() == line) {             return getEndColumn() &lt; column;         } else {             return false;         }     }      public boolean hasComment() {         return comment != null;     } }}, typeParameters=[]}]",1
Unsolved symbol : Object,1
Error calculating the type of parameter ( t) -&gt; t.getName().equals(name) of method call cu.getTypes().stream().filter(( t) -&gt; t.getName().equals(name)),35
java.lang.Object,1
com.github.javaparser.ast.NodeList cannot be cast to com.github.javaparser.ast.stmt.SwitchStmt,4
"Error calculating the type of parameter unboxedType.nameOfBoxedType of method call unboxMap.put(unboxedType.nameOfBoxedType, unboxedType)",10
No value present,216
com.github.javaparser.ast.imports.SingleStaticImportDeclaration cannot be cast to com.github.javaparser.ast.imports.StaticImportOnDemandDeclaration,20
com.github.javaparser.ast.NodeList,87
No type named &#x27;AccessThroughSuper.SubClass&#x27;found,34
Error calculating the type of parameter commentsToAttribute of method call children.addAll(commentsToAttribute),7
No type named &#x27;GenericMethodCalls.Derived&#x27;found,17
"Error calculating the type of parameter children of method call foo(children, commentsToAttribute)",7
Error calculating the type of parameter child of method call clazz.cast(child),7
com.github.javaparser.ast.NodeList cannot be cast to com.github.javaparser.ast.body.MethodDeclaration,18
Error calculating the type of parameter annotations.size() - 1 of method call annotations.get(annotations.size() - 1),8
Error calculating the type of parameter node.getChildrenNodes() of method call children.addAll(node.getChildrenNodes()),8
"Error calculating the type of parameter this of method call javadocComment.accept(this, arg)",5
"Unexpected exception, expected&lt;me.tomassetti.symbolsolver.model.declarations.MethodAmbiguityException&gt; but was&lt;java.util.NoSuchElementException&gt;",8
The type of a lambda expr depends on the position and its return value,12
Error calculating the type of parameter  p -&gt; p.toLowerCase() of method call persons.stream().map( p -&gt; p.toLowerCase()),15
Error calculating the type of parameter Collectors.toList() of method call persons.stream().collect(Collectors.toList()),3
"Unexpected exception, expected&lt;me.tomassetti.symbolsolver.model.resolution.UnsolvedSymbolException&gt; but was&lt;java.lang.StackOverflowError&gt;",1
com.github.javaparser.ast.NodeList cannot be cast to com.github.javaparser.ast.body.EnumDeclaration,8
Issur calculating the type of the scope of MethodCallExprContext{wrapped=array[0].trim()},7
Error calculating the type of parameter o of method call overloaded(o),7
Issur calculating the type of the scope of MethodCallExprContext{wrapped=t.isEmpty()},8
Error calculating the type of parameter ( t) -&gt; t.isEmpty() of method call s.filter(( t) -&gt; t.isEmpty()),11
Error calculating the type of parameter s of method call overloaded(s),7
"Error calculating the type of parameter new Long[] { 1L, 2L } of method call Arrays.asList(new Long[] { 1L, 2L })",4
"Unable to calculate the type of a parameter of a method call. Method call: foo(s), Parameter: s",4
"Unexpected exception, expected&lt;me.tomassetti.symbolsolver.model.resolution.UnsolvedSymbolException&gt; but was&lt;java.lang.ClassCastException&gt;",1
Issur calculating the type of the scope of MethodCallExprContext{wrapped=cu.getTypes().stream()},13
Unsolved symbol in Solving e : e,3
Unsolved symbol in Solving s : s,9
"Error calculating the type of parameter code of method call SourcesHelper.stringToStream(code, encoding)",3
Method &#x27;signum&#x27; cannot be resolved in context signum(beginLineWithoutConsideringAnnotation(a) - beginLineWithoutConsideringAnnotation(b)) (line: 68) MethodCallExprContext{wrapped=signum(beginLineWithoutConsideringAnnotation(a) - beginLineWithoutConsideringAnnotation(b))}. Parameter types: [PrimitiveTypeUsage{name=&#x27;int&#x27;}],4
Unsolved symbol in Solving n2 : n2,3
Unsolved symbol in Solving comments : comments,3
Unsolved symbol in Solving javadocComment : javadocComment,4
"Method &#x27;append&#x27; cannot be resolved in context buf.append(arr, 0, numChars) (line: 53) MethodCallExprContext{wrapped=buf.append(arr, 0, numChars)}. Parameter types: [PrimitiveTypeUsage{name=&#x27;char&#x27;}, PrimitiveTypeUsage{name=&#x27;int&#x27;}, PrimitiveTypeUsage{name=&#x27;int&#x27;}]",12
Unsolved symbol in Solving children : children,4
Unsolved symbol in Solving i : i,4
Issur calculating the type of the scope of MethodCallExprContext{wrapped=cu.getTypes().stream().filter(( t) -&gt; t.getName().equals(name))},7
java.lang.Class,5
Method &#x27;getName&#x27; cannot be resolved in context t.getName() (line: 23) MethodCallExprContext{wrapped=t.getName()}. Parameter types: [],4
"Method &#x27;collect&#x27; cannot be resolved in context persons.stream().collect(Collectors.toList()) (line: 9) MethodCallExprContext{wrapped=persons.stream().collect(Collectors.toList())}. Parameter types: [ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.stream.Collector}, typeParametersMap=TypeParametersMap{nameToValue={java.util.stream.Collector.T=TypeVariable {java.util.stream.Collectors.toList().T}, java.util.stream.Collector.A=WildcardUsage{type=EXTENDS, boundedType=ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.lang.Object}, typeParametersMap=TypeParametersMap{nameToValue={}}}}, java.util.stream.Collector.R=ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.List}, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {java.util.stream.Collectors.toList().T}}}}}}}]",5
"Method &#x27;map&#x27; cannot be resolved in context persons.stream().map( p -&gt; p.toLowerCase()) (line: 15) MethodCallExprContext{wrapped=persons.stream().map( p -&gt; p.toLowerCase())}. Parameter types: [ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.function.Function}, typeParametersMap=TypeParametersMap{nameToValue={java.util.function.Function.R=ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.lang.String}, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.function.Function.T=ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.lang.String}, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]",1
char E,1
null A,1
null com.github.javaparser.ast.Node,1
TypeVariable {com.github.javaparser.ast.body.BodyDeclaration.T} is not a Reference Type,4
TypeVariable {com.github.javaparser.ast.nodeTypes.NodeWithJavaDoc.T} is not a Reference Type,2
"Method &#x27;add&#x27; cannot be resolved in context _arraysAnnotations.add(visit(aux, _arg)) (line: 398) MethodCallExprContext{wrapped=_arraysAnnotations.add(visit(aux, _arg))}. Parameter types: [ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.List}, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceTypeUsage{declaration=ReflectionClassDeclaration{clazz=java.util.List}, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceTypeUsage{declaration=JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public abstract class AnnotationExpr extends Expression {      protected NameExpr name;      public AnnotationExpr() {     }      public AnnotationExpr(int beginLine, int beginColumn, int endLine, int endColumn) {         super(beginLine, beginColumn, endLine, endColumn);     }      public NameExpr getName() {         return name;     }      public void setName(NameExpr name) {         this.name = name;         setAsParentNodeOf(name);     } }}, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]",2
"Method &#x27;add&#x27; cannot be resolved in context _arraysAnnotations.add(visit(aux, _arg)) (line: 398) MethodCallExprContext{wrapped=_arraysAnnotations.add(visit(aux, _arg))}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{com.github.javaparser.ast.expr.AnnotationExpr, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]",1
boolean boolean,2
int int,3
"Method &#x27;add&#x27; cannot be resolved in context _arraysAnnotations.add(visit(aux, _arg)) (line: 398) MethodCallExprContext{wrapped=_arraysAnnotations.add(visit(aux, _arg))}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=InferenceVariableType{id=0}}}}]",2
java.lang.String null,1
Error calculating the type of parameter java.util.Locale.Category.class of method call EnumSet.noneOf(java.util.Locale.Category.class),1
JavaParserClassDeclaration{wrappedNode=public final class Generics {      Optional&lt;String&gt; s;      Optional&lt;Integer&gt; i;      Optional&lt;Generics&gt; g; }} is not a class,1
"JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public abstract class BodyDeclaration&lt;T&gt; extends Node implements NodeWithAnnotations&lt;T&gt; {      private List&lt;AnnotationExpr&gt; annotations;      public BodyDeclaration() {     }      public BodyDeclaration(List&lt;AnnotationExpr&gt; annotations) {         setAnnotations(annotations);     }      public BodyDeclaration(Range range, List&lt;AnnotationExpr&gt; annotations) {         super(range);         setAnnotations(annotations);     }      @Override     public final List&lt;AnnotationExpr&gt; getAnnotations() {         annotations = Utils.ensureNotNull(annotations);         return annotations;     }      /**      *      * @param annotations a null value is currently treated as an empty list. This behavior could change      *                    in the future, so please avoid passing null      */     @SuppressWarnings(&quot;unchecked&quot;)     @Override     public final T setAnnotations(List&lt;AnnotationExpr&gt; annotations) {         this.annotations = annotations;         setAsParentNodeOf(this.annotations);         return (T) this;     } }} is not a class",17
"JavaParserClassDeclaration{wrappedNode=public class SourcesHelper {      static String streamToString(InputStream in, String encoding) {         if (encoding == null) {             return streamToString(in);         } else {             java.util.Scanner s = new java.util.Scanner(in, encoding).useDelimiter(&quot;\\A&quot;);             return s.hasNext() ? s.next() : &quot;&quot;;         }     }      static String streamToString(InputStream in) {         java.util.Scanner s = new java.util.Scanner(in).useDelimiter(&quot;\\A&quot;);         return s.hasNext() ? s.next() : &quot;&quot;;     }      static InputStream stringToStream(String s, String encoding) throws UnsupportedEncodingException {         byte[] rawData = encoding != null ? s.getBytes(encoding) : s.getBytes();         return new ByteArrayInputStream(rawData);     }      static String readerToString(Reader reader) throws IOException {         // 8K at a time         char[] arr = new char[8 * 1024];         StringBuilder buf = new StringBuilder();         int numChars;         while ((numChars = reader.read(arr, 0, arr.length)) &gt; 0) {             buf.append(arr, 0, numChars);         }         return buf.toString();     }      static Reader stringToReader(String s) {         return new StringReader(s);     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * &lt;p&gt;  * This class was generated automatically by javacc, do not edit.  * &lt;/p&gt;  * &lt;p&gt;  * Parse Java 1.5 source code and creates Abstract Syntax Tree classes.  * &lt;/p&gt;  *  * @author Jlio Vilmar Gesser  */ public final class JavaParser {      private JavaParser() {     // hide the constructor     }      private static boolean _doNotAssignCommentsPreceedingEmptyLines = true;      private static boolean _doNotConsiderAnnotationsAsNodeStartForCodeAttribution = false;      public static boolean getDoNotConsiderAnnotationsAsNodeStartForCodeAttribution() {         return _doNotConsiderAnnotationsAsNodeStartForCodeAttribution;     }      public static void setDoNotConsiderAnnotationsAsNodeStartForCodeAttribution(boolean doNotConsiderAnnotationsAsNodeStartForCodeAttribution) {         _doNotConsiderAnnotationsAsNodeStartForCodeAttribution = doNotConsiderAnnotationsAsNodeStartForCodeAttribution;     }      public static boolean getDoNotAssignCommentsPreceedingEmptyLines() {         return _doNotAssignCommentsPreceedingEmptyLines;     }      public static void setDoNotAssignCommentsPreceedingEmptyLines(boolean doNotAssignCommentsPreceedingEmptyLines) {         _doNotAssignCommentsPreceedingEmptyLines = doNotAssignCommentsPreceedingEmptyLines;     }      public static CompilationUnit parse(final InputStream in, final String encoding) throws ParseException {         return parse(in, encoding, true);     }      /**      * Parses the Java code contained in the {@link InputStream} and returns a      * {@link CompilationUnit} that represents it.      *      * @param in      *            {@link InputStream} containing Java source code      * @param encoding      *            encoding of the source code      * @return CompilationUnit representing the Java source code      * @throws ParseException      *             if the source code has parser errors      */     public static CompilationUnit parse(final InputStream in, final String encoding, boolean considerComments) throws ParseException {         try {             String code = SourcesHelper.streamToString(in, encoding);             InputStream in1 = SourcesHelper.stringToStream(code, encoding);             CompilationUnit cu = new ASTParser(in1, encoding).CompilationUnit();             if (considerComments) {                 insertComments(cu, code);             }             return cu;         } catch (IOException ioe) {             throw new ParseException(ioe.getMessage());         }     }      /**      * Parses the Java code contained in the {@link InputStream} and returns a      * {@link CompilationUnit} that represents it.      *      * @param in      *            {@link InputStream} containing Java source code      * @return CompilationUnit representing the Java source code      * @throws ParseException      *             if the source code has parser errors      */     public static CompilationUnit parse(final InputStream in) throws ParseException {         return parse(in, null, true);     }      public static CompilationUnit parse(final File file, final String encoding) throws ParseException, IOException {         return parse(file, encoding, true);     }      /**      * Parses the Java code contained in a {@link File} and returns a      * {@link CompilationUnit} that represents it.      *      * @param file      *            {@link File} containing Java source code      * @param encoding      *            encoding of the source code      * @return CompilationUnit representing the Java source code      * @throws ParseException      *             if the source code has parser errors      * @throws IOException      */     public static CompilationUnit parse(final File file, final String encoding, boolean considerComments) throws ParseException, IOException {         final FileInputStream in = new FileInputStream(file);         try {             return parse(in, encoding, considerComments);         } finally {             in.close();         }     }      /**      * Parses the Java code contained in a {@link File} and returns a      * {@link CompilationUnit} that represents it.      *      * @param file      *            {@link File} containing Java source code      * @return CompilationUnit representing the Java source code      * @throws ParseException      *             if the source code has parser errors      * @throws IOException      */     public static CompilationUnit parse(final File file) throws ParseException, IOException {         return parse(file, null, true);     }      public static CompilationUnit parse(final Reader reader, boolean considerComments) throws ParseException {         try {             String code = SourcesHelper.readerToString(reader);             Reader reader1 = SourcesHelper.stringToReader(code);             CompilationUnit cu = new ASTParser(reader1).CompilationUnit();             if (considerComments) {                 insertComments(cu, code);             }             return cu;         } catch (IOException ioe) {             throw new ParseException(ioe.getMessage());         }     }      /**      * Parses the Java block contained in a {@link String} and returns a      * {@link BlockStmt} that represents it.      *      * @param blockStatement      *            {@link String} containing Java block code      * @return BlockStmt representing the Java block      * @throws ParseException      *             if the source code has parser errors      */     public static BlockStmt parseBlock(final String blockStatement) throws ParseException {         StringReader sr = new StringReader(blockStatement);         BlockStmt result = new ASTParser(sr).Block();         sr.close();         return result;     }      /**      * Parses the Java statement contained in a {@link String} and returns a      * {@link Statement} that represents it.      *      * @param statement      *            {@link String} containing Java statement code      * @return Statement representing the Java statement      * @throws ParseException      *             if the source code has parser errors      */     public static Statement parseStatement(final String statement) throws ParseException {         StringReader sr = new StringReader(statement);         Statement stmt = new ASTParser(sr).Statement();         sr.close();         return stmt;     }      /**      * Parses the Java import contained in a {@link String} and returns a      * {@link ImportDeclaration} that represents it.      *      * @param importDeclaration      *            {@link String} containing Java import code      * @return ImportDeclaration representing the Java import declaration      * @throws ParseException      *             if the source code has parser errors      */     public static ImportDeclaration parseImport(final String importDeclaration) throws ParseException {         StringReader sr = new StringReader(importDeclaration);         ImportDeclaration id = new ASTParser(sr).ImportDeclaration();         sr.close();         return id;     }      /**      * Parses the Java expression contained in a {@link String} and returns a      * {@link Expression} that represents it.      *      * @param expression      *            {@link String} containing Java expression      * @return Expression representing the Java expression      * @throws ParseException      *             if the source code has parser errors      */     public static Expression parseExpression(final String expression) throws ParseException {         StringReader sr = new StringReader(expression);         Expression e = new ASTParser(sr).Expression();         sr.close();         return e;     }      /**      * Parses the Java annotation contained in a {@link String} and returns a      * {@link AnnotationExpr} that represents it.      *      * @param annotation      *            {@link String} containing Java annotation      * @return AnnotationExpr representing the Java annotation      * @throws ParseException      *             if the source code has parser errors      */     public static AnnotationExpr parseAnnotation(final String annotation) throws ParseException {         StringReader sr = new StringReader(annotation);         AnnotationExpr ae = new ASTParser(sr).Annotation();         sr.close();         return ae;     }      /**      * Parses the Java body declaration(e.g fields or methods) contained in a      * {@link String} and returns a {@link BodyDeclaration} that represents it.      *      * @param body      *            {@link String} containing Java body declaration      * @return BodyDeclaration representing the Java annotation      * @throws ParseException      *             if the source code has parser errors      */     public static BodyDeclaration parseBodyDeclaration(final String body) throws ParseException {         StringReader sr = new StringReader(body);         BodyDeclaration bd = new ASTParser(sr).AnnotationBodyDeclaration();         sr.close();         return bd;     }      /**      * Comments are attributed to the thing the comment and are removed from      * allComments.      */     private static void insertCommentsInCu(CompilationUnit cu, CommentsCollection commentsCollection) {         if (commentsCollection.size() == 0)             return;         // I should sort all the direct children and the comments, if a comment is the first thing then it         // a comment to the CompilationUnit         // FIXME if there is no package it could be also a comment to the following class...         // so I could use some heuristics in these cases to distinguish the two cases         List&lt;Comment&gt; comments = commentsCollection.getAll();         PositionUtils.sortByBeginPosition(comments);         List&lt;Node&gt; children = cu.getChildrenNodes();         PositionUtils.sortByBeginPosition(children);         if (cu.getPackage() != null &amp;&amp; (children.size() == 0 || PositionUtils.areInOrder(comments.get(0), children.get(0)))) {             cu.setComment(comments.get(0));             comments.remove(0);         }         insertCommentsInNode(cu, comments);     // I should sort all the direct children and the comments, if a comment is the first thing then it     // a comment to the CompilationUnit     // FIXME if there is no package it could be also a comment to the following class...     // so I could use some heuristics in these cases to distinguish the two cases     }      private static boolean attributeLineCommentToNodeOrChild(Node node, LineComment lineComment) {         // let&#x27;s give to it the comment         if (node.getBeginLine() == lineComment.getBeginLine() &amp;&amp; !node.hasComment()) {             node.setComment(lineComment);             return true;         } else {             // try with all the children, sorted by reverse position (so the             // first one is the nearest to the comment             List&lt;Node&gt; children = new LinkedList&lt;Node&gt;();             children.addAll(node.getChildrenNodes());             PositionUtils.sortByBeginPosition(children);             Collections.reverse(children);             for (Node child : children) {                 if (attributeLineCommentToNodeOrChild(child, lineComment)) {                     return true;                 }             }             return false;         }     }      /**      * This method try to attributes the nodes received to child of the node.      * It returns the node that were not attributed.      */     private static void insertCommentsInNode(Node node, List&lt;Comment&gt; commentsToAttribute) {         if (commentsToAttribute.size() == 0)             return;         // the comments can:         // 1) Inside one of the child, then it is the child that have to associate them         // 2) If they are not inside a child they could be preceeding nothing, a comment or a child         //    if they preceed a child they are assigned to it, otherweise they remain &quot;orphans&quot;         List&lt;Node&gt; children = node.getChildrenNodes();         PositionUtils.sortByBeginPosition(children);         for (Node child : children) {             List&lt;Comment&gt; commentsInsideChild = new LinkedList&lt;Comment&gt;();             for (Comment c : commentsToAttribute) {                 if (PositionUtils.nodeContains(child, c, _doNotConsiderAnnotationsAsNodeStartForCodeAttribution)) {                     commentsInsideChild.add(c);                 }             }             commentsToAttribute.removeAll(commentsInsideChild);             insertCommentsInNode(child, commentsInsideChild);         }         // I can attribute in line comments to elements preceeding them, if there         // is something contained in their line         List&lt;Comment&gt; attributedComments = new LinkedList&lt;Comment&gt;();         for (Comment comment : commentsToAttribute) {             if (comment.isLineComment()) {                 for (Node child : children) {                     if (child.getEndLine() == comment.getBeginLine()) {                         if (attributeLineCommentToNodeOrChild(child, comment.asLineComment())) {                             attributedComments.add(comment);                         }                     }                 }             }         }         // at this point I create an ordered list of all remaining comments and children         Comment previousComment = null;         attributedComments = new LinkedList&lt;Comment&gt;();         List&lt;Node&gt; childrenAndComments = new LinkedList&lt;Node&gt;();         childrenAndComments.addAll(children);         childrenAndComments.addAll(commentsToAttribute);         PositionUtils.sortByBeginPosition(childrenAndComments, _doNotConsiderAnnotationsAsNodeStartForCodeAttribution);         for (Node thing : childrenAndComments) {             if (thing instanceof Comment) {                 previousComment = (Comment) thing;                 if (!previousComment.isOrphan()) {                     previousComment = null;                 }             } else {                 if (previousComment != null &amp;&amp; !thing.hasComment()) {                     if (!_doNotAssignCommentsPreceedingEmptyLines || !thereAreLinesBetween(previousComment, thing)) {                         thing.setComment(previousComment);                         attributedComments.add(previousComment);                         previousComment = null;                     }                 }             }         }         commentsToAttribute.removeAll(attributedComments);         // all the remaining are orphan nodes         for (Comment c : commentsToAttribute) {             if (c.isOrphan()) {                 node.addOrphanComment(c);             }         }     // the comments can:     // 1) Inside one of the child, then it is the child that have to associate them     // 2) If they are not inside a child they could be preceeding nothing, a comment or a child     //    if they preceed a child they are assigned to it, otherweise they remain &quot;orphans&quot;     // I can attribute in line comments to elements preceeding them, if there     }      private static boolean thereAreLinesBetween(Node a, Node b) {         if (!PositionUtils.areInOrder(a, b)) {             return thereAreLinesBetween(b, a);         }         int endOfA = a.getEndLine();         return b.getBeginLine() &gt; (a.getEndLine() + 1);     }      private static void insertComments(CompilationUnit cu, String code) throws IOException {         CommentsParser commentsParser = new CommentsParser();         CommentsCollection allComments = commentsParser.parse(code);         insertCommentsInCu(cu, allComments);     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * &lt;p&gt;  * AST node that represent line comments.  * &lt;/p&gt;  * Line comments are started with &quot;//&quot; and finish at the end of the line (&quot;\n&quot;).  *   * @author Julio Vilmar Gesser  */ public final class LineComment extends Comment {      public LineComment() {     }      public LineComment(String content) {         super(content);     }      public LineComment(int beginLine, int beginColumn, int endLine, int endColumn, String content) {         super(beginLine, beginColumn, endLine, endColumn, content);     }      @Override     public &lt;R, A&gt; R accept(GenericVisitor&lt;R, A&gt; v, A arg) {         return v.visit(this, arg);     }      @Override     public &lt;A&gt; void accept(VoidVisitor&lt;A&gt; v, A arg) {         v.visit(this, arg);     }      public boolean isLineComment() {         return true;     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public final class LabeledStmt extends Statement {      private String label;      private Statement stmt;      public LabeledStmt() {     }      public LabeledStmt(final String label, final Statement stmt) {         setLabel(label);         setStmt(stmt);     }      public LabeledStmt(final int beginLine, final int beginColumn, final int endLine, final int endColumn, final String label, final Statement stmt) {         super(beginLine, beginColumn, endLine, endColumn);         setLabel(label);         setStmt(stmt);     }      @Override     public &lt;R, A&gt; R accept(final GenericVisitor&lt;R, A&gt; v, final A arg) {         return v.visit(this, arg);     }      @Override     public &lt;A&gt; void accept(final VoidVisitor&lt;A&gt; v, final A arg) {         v.visit(this, arg);     }      public String getLabel() {         return label;     }      public Statement getStmt() {         return stmt;     }      public void setLabel(final String label) {         this.label = label;     }      public void setStmt(final Statement stmt) {         this.stmt = stmt;         setAsParentNodeOf(this.stmt);     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public final class ClassOrInterfaceType extends Type {      private ClassOrInterfaceType scope;      private String name;      private List&lt;Type&gt; typeArgs;      public ClassOrInterfaceType() {     }      public ClassOrInterfaceType(final String name) {         setName(name);     }      public ClassOrInterfaceType(final ClassOrInterfaceType scope, final String name) {         setScope(scope);         setName(name);     }      public ClassOrInterfaceType(final int beginLine, final int beginColumn, final int endLine, final int endColumn, final ClassOrInterfaceType scope, final String name, final List&lt;Type&gt; typeArgs) {         super(beginLine, beginColumn, endLine, endColumn);         setScope(scope);         setName(name);         setTypeArgs(typeArgs);     }      @Override     public &lt;R, A&gt; R accept(final GenericVisitor&lt;R, A&gt; v, final A arg) {         return v.visit(this, arg);     }      @Override     public &lt;A&gt; void accept(final VoidVisitor&lt;A&gt; v, final A arg) {         v.visit(this, arg);     }      public String getName() {         return name;     }      public ClassOrInterfaceType getScope() {         return scope;     }      public List&lt;Type&gt; getTypeArgs() {         return typeArgs;     }      public boolean isBoxedType() {         return PrimitiveType.unboxMap.containsKey(name);     }      public PrimitiveType toUnboxedType() throws UnsupportedOperationException {         if (!isBoxedType())             throw new UnsupportedOperationException(name + &quot; isn&#x27;t a boxed type.&quot;);         return new PrimitiveType(PrimitiveType.unboxMap.get(name));     }      public void setName(final String name) {         this.name = name;     }      public void setScope(final ClassOrInterfaceType scope) {         this.scope = scope;         setAsParentNodeOf(this.scope);     }      public void setTypeArgs(final List&lt;Type&gt; typeArgs) {         this.typeArgs = typeArgs;         setAsParentNodeOf(this.typeArgs);     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public abstract class Statement extends Node {      public Statement() {     }      public Statement(final int beginLine, final int beginColumn, final int endLine, final int endColumn) {         super(beginLine, beginColumn, endLine, endColumn);     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=public final class PositionUtils {      private PositionUtils() {     // prevent instantiation     }      public static &lt;T extends Node&gt; void sortByBeginPosition(List&lt;T&gt; nodes) {         sortByBeginPosition(nodes, false);     }      public static &lt;T extends Node&gt; void sortByBeginPosition(List&lt;T&gt; nodes, final boolean ignoringAnnotations) {         Collections.sort(nodes, new Comparator&lt;Node&gt;() {              @Override             public int compare(Node o1, Node o2) {                 return PositionUtils.compare(o1, o2, ignoringAnnotations);             }         });     }      public static boolean areInOrder(Node a, Node b) {         return areInOrder(a, b, false);     }      public static boolean areInOrder(Node a, Node b, boolean ignoringAnnotations) {         return compare(a, b, ignoringAnnotations) &lt;= 0;     }      private static int compare(Node a, Node b, boolean ignoringAnnotations) {         if (ignoringAnnotations) {             int signLine = signum(beginLineWithoutConsideringAnnotation(a) - beginLineWithoutConsideringAnnotation(b));             if (signLine == 0) {                 return signum(beginColumnWithoutConsideringAnnotation(a) - beginColumnWithoutConsideringAnnotation(b));             } else {                 return signLine;             }         }         int signLine = signum(a.getBeginLine() - b.getBeginLine());         if (signLine == 0) {             return signum(a.getBeginColumn() - b.getBeginColumn());         } else {             return signLine;         }     }      public static AnnotationExpr getLastAnnotation(Node node) {         if (node instanceof AnnotableNode) {             List&lt;AnnotationExpr&gt; annotations = new LinkedList&lt;AnnotationExpr&gt;();             annotations.addAll(((AnnotableNode) node).getAnnotations());             if (annotations.size() == 0) {                 return null;             }             sortByBeginPosition(annotations);             return annotations.get(annotations.size() - 1);         } else {             return null;         }     }      private static int beginLineWithoutConsideringAnnotation(Node node) {         return beginNodeWithoutConsideringAnnotations(node).getBeginLine();     }      private static int beginColumnWithoutConsideringAnnotation(Node node) {         return beginNodeWithoutConsideringAnnotations(node).getBeginColumn();     }      private static Node beginNodeWithoutConsideringAnnotations(Node node) {         if (node instanceof MethodDeclaration) {             MethodDeclaration casted = (MethodDeclaration) node;             return casted.getType();         } else if (node instanceof FieldDeclaration) {             FieldDeclaration casted = (FieldDeclaration) node;             return casted.getType();         } else if (node instanceof ClassOrInterfaceDeclaration) {             ClassOrInterfaceDeclaration casted = (ClassOrInterfaceDeclaration) node;             return casted.getNameExpr();         } else {             return node;         }     }      public static boolean nodeContains(Node container, Node contained, boolean ignoringAnnotations) {         if (!ignoringAnnotations || PositionUtils.getLastAnnotation(container) == null) {             return container.contains(contained);         }         if (!container.contains(contained)) {             return false;         }         // let&#x27;s not consider it contained         if (container instanceof AnnotableNode) {             int bl = beginLineWithoutConsideringAnnotation(container);             int bc = beginColumnWithoutConsideringAnnotation(container);             if (bl &gt; contained.getBeginLine())                 return false;             if (bl == contained.getBeginLine() &amp;&amp; bc &gt; contained.getBeginColumn())                 return false;             if (container.getEndLine() &lt; contained.getEndLine())                 return false;             if (container.getEndLine() == contained.getEndLine() &amp;&amp; container.getEndColumn() &lt; contained.getEndColumn())                 return false;             return true;         }         return true;     // if the node is contained, but it comes immediately after the annotations,     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public class NameExpr extends Expression implements NamedNode {      private String name;      public NameExpr() {     }      public NameExpr(final String name) {         this.name = name;     }      public NameExpr(final int beginLine, final int beginColumn, final int endLine, final int endColumn, final String name) {         super(beginLine, beginColumn, endLine, endColumn);         this.name = name;     }      @Override     public &lt;R, A&gt; R accept(final GenericVisitor&lt;R, A&gt; v, final A arg) {         return v.visit(this, arg);     }      @Override     public &lt;A&gt; void accept(final VoidVisitor&lt;A&gt; v, final A arg) {         v.visit(this, arg);     }      public final String getName() {         return name;     }      public final void setName(final String name) {         this.name = name;     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public class EqualsVisitor implements GenericVisitor&lt;Boolean, Node&gt; {      private static final EqualsVisitor SINGLETON = new EqualsVisitor();      public static boolean equals(final Node n1, final Node n2) {         return SINGLETON.nodeEquals(n1, n2);     }      private EqualsVisitor() {     // hide constructor     }      /**      * Check for equality that can be applied to each kind of node,      * to not repeat it in every method we store that here.      */     private boolean commonNodeEquality(Node n1, Node n2) {         if (!nodeEquals(n1.getComment(), n2.getComment())) {             return false;         }         if (!nodesEquals(n1.getOrphanComments(), n2.getOrphanComments())) {             return false;         }         return true;     }      private &lt;T extends Node&gt; boolean nodesEquals(final List&lt;T&gt; nodes1, final List&lt;T&gt; nodes2) {         if (nodes1 == null) {             if (nodes2 == null) {                 return true;             }             return false;         } else if (nodes2 == null) {             return false;         }         if (nodes1.size() != nodes2.size()) {             return false;         }         for (int i = 0; i &lt; nodes1.size(); i++) {             if (!nodeEquals(nodes1.get(i), nodes2.get(i))) {                 return false;             }         }         return true;     }      private &lt;T extends Node&gt; boolean nodeEquals(final T n1, final T n2) {         if (n1 == n2) {             return true;         }         if (n1 == null) {             if (n2 == null) {                 return true;             }             return false;         } else if (n2 == null) {             return false;         }         if (n1.getClass() != n2.getClass()) {             return false;         }         if (!commonNodeEquality(n1, n2)) {             return false;         }         return n1.accept(this, n2).booleanValue();     }      private boolean objEquals(final Object n1, final Object n2) {         if (n1 == n2) {             return true;         }         if (n1 == null) {             if (n2 == null) {                 return true;             }             return false;         } else if (n2 == null) {             return false;         }         return n1.equals(n2);     }      @Override     public Boolean visit(final CompilationUnit n1, final Node arg) {         final CompilationUnit n2 = (CompilationUnit) arg;         if (!nodeEquals(n1.getPackage(), n2.getPackage())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getImports(), n2.getImports())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypes(), n2.getTypes())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getComments(), n2.getComments())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final PackageDeclaration n1, final Node arg) {         final PackageDeclaration n2 = (PackageDeclaration) arg;         if (!nodeEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ImportDeclaration n1, final Node arg) {         final ImportDeclaration n2 = (ImportDeclaration) arg;         if (!nodeEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final TypeParameter n1, final Node arg) {         final TypeParameter n2 = (TypeParameter) arg;         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeBound(), n2.getTypeBound())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final LineComment n1, final Node arg) {         final LineComment n2 = (LineComment) arg;         if (!objEquals(n1.getContent(), n2.getContent())) {             return Boolean.FALSE;         }         if (!objEquals(n1.getBeginLine(), n2.getBeginLine())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final BlockComment n1, final Node arg) {         final BlockComment n2 = (BlockComment) arg;         if (!objEquals(n1.getContent(), n2.getContent())) {             return Boolean.FALSE;         }         if (!objEquals(n1.getBeginLine(), n2.getBeginLine())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ClassOrInterfaceDeclaration n1, final Node arg) {         final ClassOrInterfaceDeclaration n2 = (ClassOrInterfaceDeclaration) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (n1.isInterface() != n2.isInterface()) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeParameters(), n2.getTypeParameters())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getExtends(), n2.getExtends())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getImplements(), n2.getImplements())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getMembers(), n2.getMembers())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final EnumDeclaration n1, final Node arg) {         final EnumDeclaration n2 = (EnumDeclaration) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getImplements(), n2.getImplements())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getEntries(), n2.getEntries())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getMembers(), n2.getMembers())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final EmptyTypeDeclaration n1, final Node arg) {         return Boolean.TRUE;     }      @Override     public Boolean visit(final EnumConstantDeclaration n1, final Node arg) {         final EnumConstantDeclaration n2 = (EnumConstantDeclaration) arg;         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getArgs(), n2.getArgs())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getClassBody(), n2.getClassBody())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final AnnotationDeclaration n1, final Node arg) {         final AnnotationDeclaration n2 = (AnnotationDeclaration) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getMembers(), n2.getMembers())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final AnnotationMemberDeclaration n1, final Node arg) {         final AnnotationMemberDeclaration n2 = (AnnotationMemberDeclaration) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getDefaultValue(), n2.getDefaultValue())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final FieldDeclaration n1, final Node arg) {         final FieldDeclaration n2 = (FieldDeclaration) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getVariables(), n2.getVariables())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final VariableDeclarator n1, final Node arg) {         final VariableDeclarator n2 = (VariableDeclarator) arg;         if (!nodeEquals(n1.getId(), n2.getId())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getInit(), n2.getInit())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final VariableDeclaratorId n1, final Node arg) {         final VariableDeclaratorId n2 = (VariableDeclaratorId) arg;         if (n1.getArrayCount() != n2.getArrayCount()) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ConstructorDeclaration n1, final Node arg) {         final ConstructorDeclaration n2 = (ConstructorDeclaration) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getBlock(), n2.getBlock())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getParameters(), n2.getParameters())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getThrows(), n2.getThrows())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeParameters(), n2.getTypeParameters())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final MethodDeclaration n1, final Node arg) {         final MethodDeclaration n2 = (MethodDeclaration) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (n1.getArrayCount() != n2.getArrayCount()) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getBody(), n2.getBody())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getParameters(), n2.getParameters())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getThrows(), n2.getThrows())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeParameters(), n2.getTypeParameters())) {             return Boolean.FALSE;         }         if (n1.isDefault() != n2.isDefault()) {             return Boolean.FALSE;         }         return Boolean.TRUE;     // javadoc are checked at CompilationUnit     }      @Override     public Boolean visit(final Parameter n1, final Node arg) {         final Parameter n2 = (Parameter) arg;         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         return visit((BaseParameter) n1, arg);     }      @Override     public Boolean visit(MultiTypeParameter n1, Node arg) {         MultiTypeParameter n2 = (MultiTypeParameter) arg;         if (n1.getTypes().size() != n2.getTypes().size()) {             return Boolean.FALSE;         }         Iterator&lt;Type&gt; n1types = n1.getTypes().iterator();         Iterator&lt;Type&gt; n2types = n2.getTypes().iterator();         while (n1types.hasNext() &amp;&amp; n2types.hasNext()) {             if (!nodeEquals(n1types.next(), n2types.next())) {                 return Boolean.FALSE;             }         }         return visit((BaseParameter) n1, arg);     }      protected Boolean visit(final BaseParameter n1, final Node arg) {         final BaseParameter n2 = (BaseParameter) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getId(), n2.getId())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final EmptyMemberDeclaration n1, final Node arg) {         return Boolean.TRUE;     }      @Override     public Boolean visit(final InitializerDeclaration n1, final Node arg) {         final InitializerDeclaration n2 = (InitializerDeclaration) arg;         if (!nodeEquals(n1.getBlock(), n2.getBlock())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final JavadocComment n1, final Node arg) {         final JavadocComment n2 = (JavadocComment) arg;         if (!objEquals(n1.getContent(), n2.getContent())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ClassOrInterfaceType n1, final Node arg) {         final ClassOrInterfaceType n2 = (ClassOrInterfaceType) arg;         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getScope(), n2.getScope())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeArgs(), n2.getTypeArgs())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final PrimitiveType n1, final Node arg) {         final PrimitiveType n2 = (PrimitiveType) arg;         if (n1.getType() != n2.getType()) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ReferenceType n1, final Node arg) {         final ReferenceType n2 = (ReferenceType) arg;         if (n1.getArrayCount() != n2.getArrayCount()) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         List&lt;List&lt;AnnotationExpr&gt;&gt; n1a = n1.getArraysAnnotations();         List&lt;List&lt;AnnotationExpr&gt;&gt; n2a = n2.getArraysAnnotations();         if (n1a != null &amp;&amp; n2a != null) {             if (n1a.size() != n2a.size()) {                 return Boolean.FALSE;             } else {                 int i = 0;                 for (List&lt;AnnotationExpr&gt; aux : n1a) {                     if (!nodesEquals(aux, n2a.get(i))) {                         return Boolean.FALSE;                     }                     i++;                 }             }         } else if (n1a != n2a) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      public Boolean visit(VoidType n1, Node arg) {         VoidType n2 = (VoidType) arg;         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final WildcardType n1, final Node arg) {         final WildcardType n2 = (WildcardType) arg;         if (!nodeEquals(n1.getExtends(), n2.getExtends())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getSuper(), n2.getSuper())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final UnknownType n1, final Node arg) {         final WildcardType n2 = (WildcardType) arg;         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ArrayAccessExpr n1, final Node arg) {         final ArrayAccessExpr n2 = (ArrayAccessExpr) arg;         if (!nodeEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getIndex(), n2.getIndex())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ArrayCreationExpr n1, final Node arg) {         final ArrayCreationExpr n2 = (ArrayCreationExpr) arg;         if (n1.getArrayCount() != n2.getArrayCount()) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getInitializer(), n2.getInitializer())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getDimensions(), n2.getDimensions())) {             return Boolean.FALSE;         }         List&lt;List&lt;AnnotationExpr&gt;&gt; n1a = n1.getArraysAnnotations();         List&lt;List&lt;AnnotationExpr&gt;&gt; n2a = n2.getArraysAnnotations();         if (n1a != null &amp;&amp; n2a != null) {             if (n1a.size() != n2a.size()) {                 return Boolean.FALSE;             } else {                 int i = 0;                 for (List&lt;AnnotationExpr&gt; aux : n1a) {                     if (!nodesEquals(aux, n2a.get(i))) {                         return Boolean.FALSE;                     }                     i++;                 }             }         } else if (n1a != n2a) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ArrayInitializerExpr n1, final Node arg) {         final ArrayInitializerExpr n2 = (ArrayInitializerExpr) arg;         if (!nodesEquals(n1.getValues(), n2.getValues())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final AssignExpr n1, final Node arg) {         final AssignExpr n2 = (AssignExpr) arg;         if (n1.getOperator() != n2.getOperator()) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getTarget(), n2.getTarget())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final BinaryExpr n1, final Node arg) {         final BinaryExpr n2 = (BinaryExpr) arg;         if (n1.getOperator() != n2.getOperator()) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getLeft(), n2.getLeft())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getRight(), n2.getRight())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final CastExpr n1, final Node arg) {         final CastExpr n2 = (CastExpr) arg;         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getExpr(), n2.getExpr())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ClassExpr n1, final Node arg) {         final ClassExpr n2 = (ClassExpr) arg;         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ConditionalExpr n1, final Node arg) {         final ConditionalExpr n2 = (ConditionalExpr) arg;         if (!nodeEquals(n1.getCondition(), n2.getCondition())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getThenExpr(), n2.getThenExpr())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getElseExpr(), n2.getElseExpr())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final EnclosedExpr n1, final Node arg) {         final EnclosedExpr n2 = (EnclosedExpr) arg;         if (!nodeEquals(n1.getInner(), n2.getInner())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final FieldAccessExpr n1, final Node arg) {         final FieldAccessExpr n2 = (FieldAccessExpr) arg;         if (!nodeEquals(n1.getScope(), n2.getScope())) {             return Boolean.FALSE;         }         if (!objEquals(n1.getField(), n2.getField())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeArgs(), n2.getTypeArgs())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final InstanceOfExpr n1, final Node arg) {         final InstanceOfExpr n2 = (InstanceOfExpr) arg;         if (!nodeEquals(n1.getExpr(), n2.getExpr())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final StringLiteralExpr n1, final Node arg) {         final StringLiteralExpr n2 = (StringLiteralExpr) arg;         if (!objEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final IntegerLiteralExpr n1, final Node arg) {         final IntegerLiteralExpr n2 = (IntegerLiteralExpr) arg;         if (!objEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final LongLiteralExpr n1, final Node arg) {         final LongLiteralExpr n2 = (LongLiteralExpr) arg;         if (!objEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final IntegerLiteralMinValueExpr n1, final Node arg) {         final IntegerLiteralMinValueExpr n2 = (IntegerLiteralMinValueExpr) arg;         if (!objEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final LongLiteralMinValueExpr n1, final Node arg) {         final LongLiteralMinValueExpr n2 = (LongLiteralMinValueExpr) arg;         if (!objEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final CharLiteralExpr n1, final Node arg) {         final CharLiteralExpr n2 = (CharLiteralExpr) arg;         if (!objEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final DoubleLiteralExpr n1, final Node arg) {         final DoubleLiteralExpr n2 = (DoubleLiteralExpr) arg;         if (!objEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final BooleanLiteralExpr n1, final Node arg) {         final BooleanLiteralExpr n2 = (BooleanLiteralExpr) arg;         if (n1.getValue() != n2.getValue()) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final NullLiteralExpr n1, final Node arg) {         return Boolean.TRUE;     }      @Override     public Boolean visit(final MethodCallExpr n1, final Node arg) {         final MethodCallExpr n2 = (MethodCallExpr) arg;         if (!nodeEquals(n1.getScope(), n2.getScope())) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getArgs(), n2.getArgs())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeArgs(), n2.getTypeArgs())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final NameExpr n1, final Node arg) {         final NameExpr n2 = (NameExpr) arg;         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ObjectCreationExpr n1, final Node arg) {         final ObjectCreationExpr n2 = (ObjectCreationExpr) arg;         if (!nodeEquals(n1.getScope(), n2.getScope())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnonymousClassBody(), n2.getAnonymousClassBody())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getArgs(), n2.getArgs())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeArgs(), n2.getTypeArgs())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final QualifiedNameExpr n1, final Node arg) {         final QualifiedNameExpr n2 = (QualifiedNameExpr) arg;         if (!nodeEquals(n1.getQualifier(), n2.getQualifier())) {             return Boolean.FALSE;         }         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ThisExpr n1, final Node arg) {         final ThisExpr n2 = (ThisExpr) arg;         if (!nodeEquals(n1.getClassExpr(), n2.getClassExpr())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final SuperExpr n1, final Node arg) {         final SuperExpr n2 = (SuperExpr) arg;         if (!nodeEquals(n1.getClassExpr(), n2.getClassExpr())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final UnaryExpr n1, final Node arg) {         final UnaryExpr n2 = (UnaryExpr) arg;         if (n1.getOperator() != n2.getOperator()) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getExpr(), n2.getExpr())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final VariableDeclarationExpr n1, final Node arg) {         final VariableDeclarationExpr n2 = (VariableDeclarationExpr) arg;         if (n1.getModifiers() != n2.getModifiers()) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getAnnotations(), n2.getAnnotations())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getType(), n2.getType())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getVars(), n2.getVars())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final MarkerAnnotationExpr n1, final Node arg) {         final MarkerAnnotationExpr n2 = (MarkerAnnotationExpr) arg;         if (!nodeEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final SingleMemberAnnotationExpr n1, final Node arg) {         final SingleMemberAnnotationExpr n2 = (SingleMemberAnnotationExpr) arg;         if (!nodeEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getMemberValue(), n2.getMemberValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final NormalAnnotationExpr n1, final Node arg) {         final NormalAnnotationExpr n2 = (NormalAnnotationExpr) arg;         if (!nodeEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getPairs(), n2.getPairs())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final MemberValuePair n1, final Node arg) {         final MemberValuePair n2 = (MemberValuePair) arg;         if (!objEquals(n1.getName(), n2.getName())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getValue(), n2.getValue())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ExplicitConstructorInvocationStmt n1, final Node arg) {         final ExplicitConstructorInvocationStmt n2 = (ExplicitConstructorInvocationStmt) arg;         if (!nodeEquals(n1.getExpr(), n2.getExpr())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getArgs(), n2.getArgs())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeArgs(), n2.getTypeArgs())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final TypeDeclarationStmt n1, final Node arg) {         final TypeDeclarationStmt n2 = (TypeDeclarationStmt) arg;         if (!nodeEquals(n1.getTypeDeclaration(), n2.getTypeDeclaration())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final AssertStmt n1, final Node arg) {         final AssertStmt n2 = (AssertStmt) arg;         if (!nodeEquals(n1.getCheck(), n2.getCheck())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getMessage(), n2.getMessage())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final BlockStmt n1, final Node arg) {         final BlockStmt n2 = (BlockStmt) arg;         if (!nodesEquals(n1.getStmts(), n2.getStmts())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final LabeledStmt n1, final Node arg) {         final LabeledStmt n2 = (LabeledStmt) arg;         if (!nodeEquals(n1.getStmt(), n2.getStmt())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final EmptyStmt n1, final Node arg) {         return Boolean.TRUE;     }      @Override     public Boolean visit(final ExpressionStmt n1, final Node arg) {         final ExpressionStmt n2 = (ExpressionStmt) arg;         if (!nodeEquals(n1.getExpression(), n2.getExpression())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final SwitchStmt n1, final Node arg) {         final SwitchStmt n2 = (SwitchStmt) arg;         if (!nodeEquals(n1.getSelector(), n2.getSelector())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getEntries(), n2.getEntries())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final SwitchEntryStmt n1, final Node arg) {         final SwitchEntryStmt n2 = (SwitchEntryStmt) arg;         if (!nodeEquals(n1.getLabel(), n2.getLabel())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getStmts(), n2.getStmts())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final BreakStmt n1, final Node arg) {         final BreakStmt n2 = (BreakStmt) arg;         if (!objEquals(n1.getId(), n2.getId())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ReturnStmt n1, final Node arg) {         final ReturnStmt n2 = (ReturnStmt) arg;         if (!nodeEquals(n1.getExpr(), n2.getExpr())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final IfStmt n1, final Node arg) {         final IfStmt n2 = (IfStmt) arg;         if (!nodeEquals(n1.getCondition(), n2.getCondition())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getThenStmt(), n2.getThenStmt())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getElseStmt(), n2.getElseStmt())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final WhileStmt n1, final Node arg) {         final WhileStmt n2 = (WhileStmt) arg;         if (!nodeEquals(n1.getCondition(), n2.getCondition())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getBody(), n2.getBody())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ContinueStmt n1, final Node arg) {         final ContinueStmt n2 = (ContinueStmt) arg;         if (!objEquals(n1.getId(), n2.getId())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final DoStmt n1, final Node arg) {         final DoStmt n2 = (DoStmt) arg;         if (!nodeEquals(n1.getBody(), n2.getBody())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getCondition(), n2.getCondition())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ForeachStmt n1, final Node arg) {         final ForeachStmt n2 = (ForeachStmt) arg;         if (!nodeEquals(n1.getVariable(), n2.getVariable())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getIterable(), n2.getIterable())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getBody(), n2.getBody())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ForStmt n1, final Node arg) {         final ForStmt n2 = (ForStmt) arg;         if (!nodesEquals(n1.getInit(), n2.getInit())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getCompare(), n2.getCompare())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getUpdate(), n2.getUpdate())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getBody(), n2.getBody())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final ThrowStmt n1, final Node arg) {         final ThrowStmt n2 = (ThrowStmt) arg;         if (!nodeEquals(n1.getExpr(), n2.getExpr())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final SynchronizedStmt n1, final Node arg) {         final SynchronizedStmt n2 = (SynchronizedStmt) arg;         if (!nodeEquals(n1.getExpr(), n2.getExpr())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getBlock(), n2.getBlock())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final TryStmt n1, final Node arg) {         final TryStmt n2 = (TryStmt) arg;         if (!nodeEquals(n1.getTryBlock(), n2.getTryBlock())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getCatchs(), n2.getCatchs())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getFinallyBlock(), n2.getFinallyBlock())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(final CatchClause n1, final Node arg) {         final CatchClause n2 = (CatchClause) arg;         if (!nodeEquals(n1.getExcept(), n2.getExcept())) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getCatchBlock(), n2.getCatchBlock())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(LambdaExpr n1, Node arg) {         LambdaExpr n2 = (LambdaExpr) arg;         if (!nodesEquals(n1.getParameters(), n2.getParameters())) {             return Boolean.FALSE;         }         if (n1.isParametersEnclosed() != n2.isParametersEnclosed()) {             return Boolean.FALSE;         }         if (!nodeEquals(n1.getBody(), n2.getBody())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(MethodReferenceExpr n1, Node arg) {         MethodReferenceExpr n2 = (MethodReferenceExpr) arg;         if (!nodeEquals(n1.getScope(), n2.getScope())) {             return Boolean.FALSE;         }         if (!nodesEquals(n1.getTypeParameters(), n2.getTypeParameters())) {             return Boolean.FALSE;         }         if (!objEquals(n1.getIdentifier(), n2.getIdentifier())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     }      @Override     public Boolean visit(TypeExpr n, Node arg) {         TypeExpr n2 = (TypeExpr) arg;         if (!nodeEquals(n.getType(), n2.getType())) {             return Boolean.FALSE;         }         return Boolean.TRUE;     } }} is not a class",1
JavaParserClassDeclaration{wrappedNode=/**  * @author Federico Tomassetti  * @since 2.0.1  */ public class Utils {      public static &lt;T&gt; List&lt;T&gt; ensureNotNull(List&lt;T&gt; list) {         return list == null ? Collections.&lt;T&gt;emptyList() : list;     }      public static &lt;E&gt; boolean isNullOrEmpty(Collection&lt;E&gt; collection) {         return collection == null || collection.isEmpty();     } }} is not a class,1
"JavaParserClassDeclaration{wrappedNode=public class CloneVisitor implements GenericVisitor&lt;Node, Object&gt; {      @Override     public Node visit(CompilationUnit _n, Object _arg) {         PackageDeclaration package_ = cloneNodes(_n.getPackage(), _arg);         List&lt;ImportDeclaration&gt; imports = visit(_n.getImports(), _arg);         List&lt;TypeDeclaration&gt; types = visit(_n.getTypes(), _arg);         return new CompilationUnit(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), package_, imports, types);     }      @Override     public Node visit(PackageDeclaration _n, Object _arg) {         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         NameExpr name = cloneNodes(_n.getName(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         PackageDeclaration r = new PackageDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), annotations, name);         r.setComment(comment);         return r;     }      @Override     public Node visit(ImportDeclaration _n, Object _arg) {         NameExpr name = cloneNodes(_n.getName(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ImportDeclaration r = new ImportDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), name, _n.isStatic(), _n.isAsterisk());         r.setComment(comment);         return r;     }      @Override     public Node visit(TypeParameter _n, Object _arg) {         List&lt;ClassOrInterfaceType&gt; typeBound = visit(_n.getTypeBound(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         TypeParameter r = new TypeParameter(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getName(), typeBound, annotations);         Comment comment = cloneNodes(_n.getComment(), _arg);         r.setComment(comment);         return r;     }      @Override     public Node visit(LineComment _n, Object _arg) {         return new LineComment(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getContent());     }      @Override     public Node visit(BlockComment _n, Object _arg) {         return new BlockComment(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getContent());     }      @Override     public Node visit(ClassOrInterfaceDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         List&lt;TypeParameter&gt; typeParameters = visit(_n.getTypeParameters(), _arg);         List&lt;ClassOrInterfaceType&gt; extendsList = visit(_n.getExtends(), _arg);         List&lt;ClassOrInterfaceType&gt; implementsList = visit(_n.getImplements(), _arg);         List&lt;BodyDeclaration&gt; members = visit(_n.getMembers(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ClassOrInterfaceDeclaration r = new ClassOrInterfaceDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, _n.isInterface(), _n.getName(), typeParameters, extendsList, implementsList, members);         r.setComment(comment);         return r;     }      @Override     public Node visit(EnumDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         List&lt;ClassOrInterfaceType&gt; implementsList = visit(_n.getImplements(), _arg);         List&lt;EnumConstantDeclaration&gt; entries = visit(_n.getEntries(), _arg);         List&lt;BodyDeclaration&gt; members = visit(_n.getMembers(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         EnumDeclaration r = new EnumDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, _n.getName(), implementsList, entries, members);         r.setComment(comment);         return r;     }      @Override     public Node visit(EmptyTypeDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         EmptyTypeDeclaration r = new EmptyTypeDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn());         r.setComment(comment);         return r;     }      @Override     public Node visit(EnumConstantDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         List&lt;Expression&gt; args = visit(_n.getArgs(), _arg);         List&lt;BodyDeclaration&gt; classBody = visit(_n.getClassBody(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         EnumConstantDeclaration r = new EnumConstantDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), annotations, _n.getName(), args, classBody);         r.setComment(comment);         return r;     }      @Override     public Node visit(AnnotationDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         List&lt;BodyDeclaration&gt; members = visit(_n.getMembers(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         AnnotationDeclaration r = new AnnotationDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, _n.getName(), members);         r.setComment(comment);         return r;     }      @Override     public Node visit(AnnotationMemberDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         Type type_ = cloneNodes(_n.getType(), _arg);         Expression defaultValue = cloneNodes(_n.getDefaultValue(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         AnnotationMemberDeclaration r = new AnnotationMemberDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, type_, _n.getName(), defaultValue);         r.setComment(comment);         return r;     }      @Override     public Node visit(FieldDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         Type type_ = cloneNodes(_n.getType(), _arg);         List&lt;VariableDeclarator&gt; variables = visit(_n.getVariables(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         FieldDeclaration r = new FieldDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, type_, variables);         r.setComment(comment);         return r;     }      @Override     public Node visit(VariableDeclarator _n, Object _arg) {         VariableDeclaratorId id = cloneNodes(_n.getId(), _arg);         Expression init = cloneNodes(_n.getInit(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         VariableDeclarator r = new VariableDeclarator(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), id, init);         r.setComment(comment);         return r;     }      @Override     public Node visit(VariableDeclaratorId _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         VariableDeclaratorId r = new VariableDeclaratorId(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getName(), _n.getArrayCount());         r.setComment(comment);         return r;     }      @Override     public Node visit(ConstructorDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         List&lt;TypeParameter&gt; typeParameters = visit(_n.getTypeParameters(), _arg);         List&lt;Parameter&gt; parameters = visit(_n.getParameters(), _arg);         List&lt;NameExpr&gt; throws_ = visit(_n.getThrows(), _arg);         BlockStmt block = cloneNodes(_n.getBlock(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ConstructorDeclaration r = new ConstructorDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, typeParameters, _n.getName(), parameters, throws_, block);         r.setComment(comment);         return r;     }      @Override     public Node visit(MethodDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         List&lt;TypeParameter&gt; typeParameters = visit(_n.getTypeParameters(), _arg);         Type type_ = cloneNodes(_n.getType(), _arg);         List&lt;Parameter&gt; parameters = visit(_n.getParameters(), _arg);         List&lt;NameExpr&gt; throws_ = visit(_n.getThrows(), _arg);         BlockStmt block = cloneNodes(_n.getBody(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         MethodDeclaration r = new MethodDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, typeParameters, type_, _n.getName(), parameters, _n.getArrayCount(), throws_, block);         r.setComment(comment);         return r;     }      @Override     public Node visit(Parameter _n, Object _arg) {         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         Type type_ = cloneNodes(_n.getType(), _arg);         VariableDeclaratorId id = cloneNodes(_n.getId(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         Parameter r = new Parameter(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, type_, _n.isVarArgs(), id);         r.setComment(comment);         return r;     }      @Override     public Node visit(MultiTypeParameter _n, Object _arg) {         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         List&lt;Type&gt; types = visit(_n.getTypes(), _arg);         VariableDeclaratorId id = cloneNodes(_n.getId(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         MultiTypeParameter r = new MultiTypeParameter(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, types, id);         r.setComment(comment);         return r;     }      @Override     public Node visit(EmptyMemberDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         EmptyMemberDeclaration r = new EmptyMemberDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn());         r.setComment(comment);         return r;     }      @Override     public Node visit(InitializerDeclaration _n, Object _arg) {         JavadocComment javaDoc = cloneNodes(_n.getJavaDoc(), _arg);         BlockStmt block = cloneNodes(_n.getBlock(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         InitializerDeclaration r = new InitializerDeclaration(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.isStatic(), block);         r.setComment(comment);         return r;     }      @Override     public Node visit(JavadocComment _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         JavadocComment r = new JavadocComment(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getContent());         r.setComment(comment);         return r;     }      @Override     public Node visit(ClassOrInterfaceType _n, Object _arg) {         ClassOrInterfaceType scope = cloneNodes(_n.getScope(), _arg);         List&lt;Type&gt; typeArgs = visit(_n.getTypeArgs(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ClassOrInterfaceType r = new ClassOrInterfaceType(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), scope, _n.getName(), typeArgs);         r.setComment(comment);         return r;     }      @Override     public Node visit(PrimitiveType _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         PrimitiveType r = new PrimitiveType(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getType());         r.setComment(comment);         return r;     }      @Override     public Node visit(ReferenceType _n, Object _arg) {         List&lt;AnnotationExpr&gt; ann = visit(_n.getAnnotations(), _arg);         Type type_ = cloneNodes(_n.getType(), _arg);         List&lt;List&lt;AnnotationExpr&gt;&gt; arraysAnnotations = _n.getArraysAnnotations();         List&lt;List&lt;AnnotationExpr&gt;&gt; _arraysAnnotations = null;         if (arraysAnnotations != null) {             _arraysAnnotations = new LinkedList&lt;List&lt;AnnotationExpr&gt;&gt;();             for (List&lt;AnnotationExpr&gt; aux : arraysAnnotations) {                 _arraysAnnotations.add(visit(aux, _arg));             }         }         ReferenceType r = new ReferenceType(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), type_, _n.getArrayCount(), ann, _arraysAnnotations);         Comment comment = cloneNodes(_n.getComment(), _arg);         r.setComment(comment);         return r;     }      @Override     public Node visit(VoidType _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         VoidType r = new VoidType(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn());         r.setComment(comment);         return r;     }      @Override     public Node visit(WildcardType _n, Object _arg) {         ReferenceType ext = cloneNodes(_n.getExtends(), _arg);         ReferenceType sup = cloneNodes(_n.getSuper(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         WildcardType r = new WildcardType(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), ext, sup);         r.setComment(comment);         return r;     }      @Override     public Node visit(UnknownType _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         UnknownType r = new UnknownType();         r.setComment(comment);         return r;     }      @Override     public Node visit(ArrayAccessExpr _n, Object _arg) {         Expression name = cloneNodes(_n.getName(), _arg);         Expression index = cloneNodes(_n.getIndex(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ArrayAccessExpr r = new ArrayAccessExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), name, index);         r.setComment(comment);         return r;     }      @Override     public Node visit(ArrayCreationExpr _n, Object _arg) {         Type type_ = cloneNodes(_n.getType(), _arg);         List&lt;Expression&gt; dimensions = visit(_n.getDimensions(), _arg);         ArrayCreationExpr r = new ArrayCreationExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), type_, dimensions, _n.getArrayCount());         if (_n.getInitializer() != null) {             // ArrayCreationExpr has two mutually             // exclusive constructors             r.setInitializer(cloneNodes(_n.getInitializer(), _arg));         }         List&lt;List&lt;AnnotationExpr&gt;&gt; arraysAnnotations = _n.getArraysAnnotations();         List&lt;List&lt;AnnotationExpr&gt;&gt; _arraysAnnotations = null;         if (arraysAnnotations != null) {             _arraysAnnotations = new LinkedList&lt;List&lt;AnnotationExpr&gt;&gt;();             for (List&lt;AnnotationExpr&gt; aux : arraysAnnotations) {                 _arraysAnnotations.add(visit(aux, _arg));             }         }         r.setArraysAnnotations(_arraysAnnotations);         Comment comment = cloneNodes(_n.getComment(), _arg);         r.setComment(comment);         return r;     }      @Override     public Node visit(ArrayInitializerExpr _n, Object _arg) {         List&lt;Expression&gt; values = visit(_n.getValues(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ArrayInitializerExpr r = new ArrayInitializerExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), values);         r.setComment(comment);         return r;     }      @Override     public Node visit(AssignExpr _n, Object _arg) {         Expression target = cloneNodes(_n.getTarget(), _arg);         Expression value = cloneNodes(_n.getValue(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         AssignExpr r = new AssignExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), target, value, _n.getOperator());         r.setComment(comment);         return r;     }      @Override     public Node visit(BinaryExpr _n, Object _arg) {         Expression left = cloneNodes(_n.getLeft(), _arg);         Expression right = cloneNodes(_n.getRight(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         BinaryExpr r = new BinaryExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), left, right, _n.getOperator());         r.setComment(comment);         return r;     }      @Override     public Node visit(CastExpr _n, Object _arg) {         Type type_ = cloneNodes(_n.getType(), _arg);         Expression expr = cloneNodes(_n.getExpr(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         CastExpr r = new CastExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), type_, expr);         r.setComment(comment);         return r;     }      @Override     public Node visit(ClassExpr _n, Object _arg) {         Type type_ = cloneNodes(_n.getType(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ClassExpr r = new ClassExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), type_);         r.setComment(comment);         return r;     }      @Override     public Node visit(ConditionalExpr _n, Object _arg) {         Expression condition = cloneNodes(_n.getCondition(), _arg);         Expression thenExpr = cloneNodes(_n.getThenExpr(), _arg);         Expression elseExpr = cloneNodes(_n.getElseExpr(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ConditionalExpr r = new ConditionalExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), condition, thenExpr, elseExpr);         r.setComment(comment);         return r;     }      @Override     public Node visit(EnclosedExpr _n, Object _arg) {         Expression inner = cloneNodes(_n.getInner(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         EnclosedExpr r = new EnclosedExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), inner);         r.setComment(comment);         return r;     }      @Override     public Node visit(FieldAccessExpr _n, Object _arg) {         Expression scope = cloneNodes(_n.getScope(), _arg);         List&lt;Type&gt; typeArgs = visit(_n.getTypeArgs(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         FieldAccessExpr r = new FieldAccessExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), scope, typeArgs, _n.getField());         r.setComment(comment);         return r;     }      @Override     public Node visit(InstanceOfExpr _n, Object _arg) {         Expression expr = cloneNodes(_n.getExpr(), _arg);         Type type_ = cloneNodes(_n.getType(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         InstanceOfExpr r = new InstanceOfExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), expr, type_);         r.setComment(comment);         return r;     }      @Override     public Node visit(StringLiteralExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         StringLiteralExpr r = new StringLiteralExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getValue());         r.setComment(comment);         return r;     }      @Override     public Node visit(IntegerLiteralExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         IntegerLiteralExpr r = new IntegerLiteralExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getValue());         r.setComment(comment);         return r;     }      @Override     public Node visit(LongLiteralExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         LongLiteralExpr r = new LongLiteralExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getValue());         r.setComment(comment);         return r;     }      @Override     public Node visit(IntegerLiteralMinValueExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         IntegerLiteralMinValueExpr r = new IntegerLiteralMinValueExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn());         r.setComment(comment);         return r;     }      @Override     public Node visit(LongLiteralMinValueExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         LongLiteralMinValueExpr r = new LongLiteralMinValueExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn());         r.setComment(comment);         return r;     }      @Override     public Node visit(CharLiteralExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         CharLiteralExpr r = new CharLiteralExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getValue());         r.setComment(comment);         return r;     }      @Override     public Node visit(DoubleLiteralExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         DoubleLiteralExpr r = new DoubleLiteralExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getValue());         r.setComment(comment);         return r;     }      @Override     public Node visit(BooleanLiteralExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         BooleanLiteralExpr r = new BooleanLiteralExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getValue());         r.setComment(comment);         return r;     }      @Override     public Node visit(NullLiteralExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         NullLiteralExpr r = new NullLiteralExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn());         r.setComment(comment);         return r;     }      @Override     public Node visit(MethodCallExpr _n, Object _arg) {         Expression scope = cloneNodes(_n.getScope(), _arg);         List&lt;Type&gt; typeArgs = visit(_n.getTypeArgs(), _arg);         List&lt;Expression&gt; args = visit(_n.getArgs(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         MethodCallExpr r = new MethodCallExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), scope, typeArgs, _n.getName(), args);         r.setComment(comment);         return r;     }      @Override     public Node visit(NameExpr _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         NameExpr r = new NameExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getName());         r.setComment(comment);         return r;     }      @Override     public Node visit(ObjectCreationExpr _n, Object _arg) {         Expression scope = cloneNodes(_n.getScope(), _arg);         ClassOrInterfaceType type_ = cloneNodes(_n.getType(), _arg);         List&lt;Type&gt; typeArgs = visit(_n.getTypeArgs(), _arg);         List&lt;Expression&gt; args = visit(_n.getArgs(), _arg);         List&lt;BodyDeclaration&gt; anonymousBody = visit(_n.getAnonymousClassBody(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ObjectCreationExpr r = new ObjectCreationExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), scope, type_, typeArgs, args, anonymousBody);         r.setComment(comment);         return r;     }      @Override     public Node visit(QualifiedNameExpr _n, Object _arg) {         NameExpr scope = cloneNodes(_n.getQualifier(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         QualifiedNameExpr r = new QualifiedNameExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), scope, _n.getName());         r.setComment(comment);         return r;     }      @Override     public Node visit(ThisExpr _n, Object _arg) {         Expression classExpr = cloneNodes(_n.getClassExpr(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ThisExpr r = new ThisExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), classExpr);         r.setComment(comment);         return r;     }      @Override     public Node visit(SuperExpr _n, Object _arg) {         Expression classExpr = cloneNodes(_n.getClassExpr(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         SuperExpr r = new SuperExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), classExpr);         r.setComment(comment);         return r;     }      @Override     public Node visit(UnaryExpr _n, Object _arg) {         Expression expr = cloneNodes(_n.getExpr(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         UnaryExpr r = new UnaryExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), expr, _n.getOperator());         r.setComment(comment);         return r;     }      @Override     public Node visit(VariableDeclarationExpr _n, Object _arg) {         List&lt;AnnotationExpr&gt; annotations = visit(_n.getAnnotations(), _arg);         Type type_ = cloneNodes(_n.getType(), _arg);         List&lt;VariableDeclarator&gt; vars = visit(_n.getVars(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         VariableDeclarationExpr r = new VariableDeclarationExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getModifiers(), annotations, type_, vars);         r.setComment(comment);         return r;     }      @Override     public Node visit(MarkerAnnotationExpr _n, Object _arg) {         NameExpr name = cloneNodes(_n.getName(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         MarkerAnnotationExpr r = new MarkerAnnotationExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), name);         r.setComment(comment);         return r;     }      @Override     public Node visit(SingleMemberAnnotationExpr _n, Object _arg) {         NameExpr name = cloneNodes(_n.getName(), _arg);         Expression memberValue = cloneNodes(_n.getMemberValue(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         SingleMemberAnnotationExpr r = new SingleMemberAnnotationExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), name, memberValue);         r.setComment(comment);         return r;     }      @Override     public Node visit(NormalAnnotationExpr _n, Object _arg) {         NameExpr name = cloneNodes(_n.getName(), _arg);         List&lt;MemberValuePair&gt; pairs = visit(_n.getPairs(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         NormalAnnotationExpr r = new NormalAnnotationExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), name, pairs);         r.setComment(comment);         return r;     }      @Override     public Node visit(MemberValuePair _n, Object _arg) {         Expression value = cloneNodes(_n.getValue(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         MemberValuePair r = new MemberValuePair(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getName(), value);         r.setComment(comment);         return r;     }      @Override     public Node visit(ExplicitConstructorInvocationStmt _n, Object _arg) {         List&lt;Type&gt; typeArgs = visit(_n.getTypeArgs(), _arg);         Expression expr = cloneNodes(_n.getExpr(), _arg);         List&lt;Expression&gt; args = visit(_n.getArgs(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ExplicitConstructorInvocationStmt r = new ExplicitConstructorInvocationStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), typeArgs, _n.isThis(), expr, args);         r.setComment(comment);         return r;     }      @Override     public Node visit(TypeDeclarationStmt _n, Object _arg) {         TypeDeclaration typeDecl = cloneNodes(_n.getTypeDeclaration(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         TypeDeclarationStmt r = new TypeDeclarationStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), typeDecl);         r.setComment(comment);         return r;     }      @Override     public Node visit(AssertStmt _n, Object _arg) {         Expression check = cloneNodes(_n.getCheck(), _arg);         Expression message = cloneNodes(_n.getMessage(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         AssertStmt r = new AssertStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), check, message);         r.setComment(comment);         return r;     }      @Override     public Node visit(BlockStmt _n, Object _arg) {         List&lt;Statement&gt; stmts = visit(_n.getStmts(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         BlockStmt r = new BlockStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), stmts);         r.setComment(comment);         return r;     }      @Override     public Node visit(LabeledStmt _n, Object _arg) {         Statement stmt = cloneNodes(_n.getStmt(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         LabeledStmt r = new LabeledStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getLabel(), stmt);         r.setComment(comment);         return r;     }      @Override     public Node visit(EmptyStmt _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         EmptyStmt r = new EmptyStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn());         r.setComment(comment);         return r;     }      @Override     public Node visit(ExpressionStmt _n, Object _arg) {         Expression expr = cloneNodes(_n.getExpression(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ExpressionStmt r = new ExpressionStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), expr);         r.setComment(comment);         return r;     }      @Override     public Node visit(SwitchStmt _n, Object _arg) {         Expression selector = cloneNodes(_n.getSelector(), _arg);         List&lt;SwitchEntryStmt&gt; entries = visit(_n.getEntries(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         SwitchStmt r = new SwitchStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), selector, entries);         r.setComment(comment);         return r;     }      @Override     public Node visit(SwitchEntryStmt _n, Object _arg) {         Expression label = cloneNodes(_n.getLabel(), _arg);         List&lt;Statement&gt; stmts = visit(_n.getStmts(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         SwitchEntryStmt r = new SwitchEntryStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), label, stmts);         r.setComment(comment);         return r;     }      @Override     public Node visit(BreakStmt _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         BreakStmt r = new BreakStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getId());         r.setComment(comment);         return r;     }      @Override     public Node visit(ReturnStmt _n, Object _arg) {         Expression expr = cloneNodes(_n.getExpr(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ReturnStmt r = new ReturnStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), expr);         r.setComment(comment);         return r;     }      @Override     public Node visit(IfStmt _n, Object _arg) {         Expression condition = cloneNodes(_n.getCondition(), _arg);         Statement thenStmt = cloneNodes(_n.getThenStmt(), _arg);         Statement elseStmt = cloneNodes(_n.getElseStmt(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         IfStmt r = new IfStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), condition, thenStmt, elseStmt);         r.setComment(comment);         return r;     }      @Override     public Node visit(WhileStmt _n, Object _arg) {         Expression condition = cloneNodes(_n.getCondition(), _arg);         Statement body = cloneNodes(_n.getBody(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         WhileStmt r = new WhileStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), condition, body);         r.setComment(comment);         return r;     }      @Override     public Node visit(ContinueStmt _n, Object _arg) {         Comment comment = cloneNodes(_n.getComment(), _arg);         ContinueStmt r = new ContinueStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), _n.getId());         r.setComment(comment);         return r;     }      @Override     public Node visit(DoStmt _n, Object _arg) {         Statement body = cloneNodes(_n.getBody(), _arg);         Expression condition = cloneNodes(_n.getCondition(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         DoStmt r = new DoStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), body, condition);         r.setComment(comment);         return r;     }      @Override     public Node visit(ForeachStmt _n, Object _arg) {         VariableDeclarationExpr var = cloneNodes(_n.getVariable(), _arg);         Expression iterable = cloneNodes(_n.getIterable(), _arg);         Statement body = cloneNodes(_n.getBody(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ForeachStmt r = new ForeachStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), var, iterable, body);         r.setComment(comment);         return r;     }      @Override     public Node visit(ForStmt _n, Object _arg) {         List&lt;Expression&gt; init = visit(_n.getInit(), _arg);         Expression compare = cloneNodes(_n.getCompare(), _arg);         List&lt;Expression&gt; update = visit(_n.getUpdate(), _arg);         Statement body = cloneNodes(_n.getBody(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ForStmt r = new ForStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), init, compare, update, body);         r.setComment(comment);         return r;     }      @Override     public Node visit(ThrowStmt _n, Object _arg) {         Expression expr = cloneNodes(_n.getExpr(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         ThrowStmt r = new ThrowStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), expr);         r.setComment(comment);         return r;     }      @Override     public Node visit(SynchronizedStmt _n, Object _arg) {         Expression expr = cloneNodes(_n.getExpr(), _arg);         BlockStmt block = cloneNodes(_n.getBlock(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         SynchronizedStmt r = new SynchronizedStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), expr, block);         r.setComment(comment);         return r;     }      @Override     public Node visit(TryStmt _n, Object _arg) {         List&lt;VariableDeclarationExpr&gt; resources = visit(_n.getResources(), _arg);         BlockStmt tryBlock = cloneNodes(_n.getTryBlock(), _arg);         List&lt;CatchClause&gt; catchs = visit(_n.getCatchs(), _arg);         BlockStmt finallyBlock = cloneNodes(_n.getFinallyBlock(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         TryStmt r = new TryStmt(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), resources, tryBlock, catchs, finallyBlock);         r.setComment(comment);         return r;     }      @Override     public Node visit(CatchClause _n, Object _arg) {         MultiTypeParameter except = cloneNodes(_n.getExcept(), _arg);         BlockStmt catchBlock = cloneNodes(_n.getCatchBlock(), _arg);         Comment comment = cloneNodes(_n.getComment(), _arg);         CatchClause r = new CatchClause(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), except.getModifiers(), except.getAnnotations(), except.getTypes(), except.getId(), catchBlock);         r.setComment(comment);         return r;     }      @Override     public Node visit(LambdaExpr _n, Object _arg) {         List&lt;Parameter&gt; lambdaParameters = visit(_n.getParameters(), _arg);         Statement body = cloneNodes(_n.getBody(), _arg);         LambdaExpr r = new LambdaExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), lambdaParameters, body, _n.isParametersEnclosed());         return r;     }      @Override     public Node visit(MethodReferenceExpr _n, Object arg) {         List&lt;TypeParameter&gt; typeParams = visit(_n.getTypeParameters(), arg);         Expression scope = cloneNodes(_n.getScope(), arg);         MethodReferenceExpr r = new MethodReferenceExpr(_n.getBeginLine(), _n.getBeginColumn(), _n.getEndLine(), _n.getEndColumn(), scope, typeParams, _n.getIdentifier());         return r;     }      @Override     public Node visit(TypeExpr n, Object arg) {         Type t = cloneNodes(n.getType(), arg);         TypeExpr r = new TypeExpr(n.getBeginLine(), n.getBeginColumn(), n.getEndLine(), n.getEndColumn(), t);         return r;     }      public &lt;T extends Node&gt; List&lt;T&gt; visit(List&lt;T&gt; _nodes, Object _arg) {         if (_nodes == null)             return null;         List&lt;T&gt; r = new ArrayList&lt;T&gt;(_nodes.size());         for (T n : _nodes) {             T rN = cloneNodes(n, _arg);             if (rN != null)                 r.add(rN);         }         return r;     }      protected &lt;T extends Node&gt; T cloneNodes(T _node, Object _arg) {         if (_node == null)             return null;         Node r = _node.accept(this, _arg);         if (r == null)             return null;         return (T) r;     } }} is not a class",1
"JavaParserClassDeclaration{wrappedNode=/**  * @author Julio Vilmar Gesser  */ public final class CatchClause extends Node {      private MultiTypeParameter except;      private BlockStmt catchBlock;      public CatchClause() {     }      public CatchClause(final MultiTypeParameter except, final BlockStmt catchBlock) {         setExcept(except);         setCatchBlock(catchBlock);     }      public CatchClause(int exceptModifier, List&lt;AnnotationExpr&gt; exceptAnnotations, List&lt;Type&gt; exceptTypes, VariableDeclaratorId exceptId, BlockStmt catchBlock) {         this(new MultiTypeParameter(exceptModifier, exceptAnnotations, exceptTypes, exceptId), catchBlock);     }      public CatchClause(final int beginLine, final int beginColumn, final int endLine, final int endColumn, final int exceptModifier, final List&lt;AnnotationExpr&gt; exceptAnnotations, final List&lt;Type&gt; exceptTypes, final VariableDeclaratorId exceptId, final BlockStmt catchBlock) {         super(beginLine, beginColumn, endLine, endColumn);         setExcept(new MultiTypeParameter(beginLine, beginColumn, endLine, endColumn, exceptModifier, exceptAnnotations, exceptTypes, exceptId));         setCatchBlock(catchBlock);     }      @Override     public &lt;R, A&gt; R accept(final GenericVisitor&lt;R, A&gt; v, final A arg) {         return v.visit(this, arg);     }      @Override     public &lt;A&gt; void accept(final VoidVisitor&lt;A&gt; v, final A arg) {         v.visit(this, arg);     }      public BlockStmt getCatchBlock() {         return catchBlock;     }      public MultiTypeParameter getExcept() {         return except;     }      public void setCatchBlock(final BlockStmt catchBlock) {         this.catchBlock = catchBlock;         setAsParentNodeOf(this.catchBlock);     }      public void setExcept(final MultiTypeParameter except) {         this.except = except;         setAsParentNodeOf(this.except);     } }} is not a class",1
JavaParserClassDeclaration{wrappedNode=class SuperClass {      protected String field;      protected String method() {         return field;     } }} is not a class,2
ReflectionClassDeclaration{clazz=java.lang.Object} is not a class,5
JavaParserClassDeclaration{wrappedNode=class Node { }} is not a class,1
"Unexpected exception, expected&lt;com.github.javaparser.symbolsolver.model.declarations.MethodAmbiguityException&gt; but was&lt;java.lang.UnsupportedOperationException&gt;",2
JavaParserClassDeclaration{wrappedNode=class Super {      protected boolean k;      public static char m; }} is not a class,8
JavaParserClassDeclaration{wrappedNode=class ReferencesToField {      int i;      public void method1() {         i = 2;     } }} is not a class,1
"JavaParserClassDeclaration{wrappedNode=/**  * &lt;p&gt;  * This class represents the entire compilation unit. Each java file denotes a  * compilation unit.  * &lt;/p&gt;  * The CompilationUnit is constructed following the syntax:&lt;br&gt;  * &lt;pre&gt;  * {@code  * CompilationUnit ::=  ( }{@link PackageDeclaration}{@code )?  *                      ( }{@link ImportDeclaration}{@code )*  *                      ( }{@link TypeDeclaration}{@code )*  * }  * &lt;/pre&gt;  * @author Julio Vilmar Gesser  */ public final class CompilationUnit extends Node {      private PackageDeclaration pakage;      private List&lt;ImportDeclaration&gt; imports;      private List&lt;TypeDeclaration&gt; types;      public CompilationUnit() {     }      public CompilationUnit(PackageDeclaration pakage, List&lt;ImportDeclaration&gt; imports, List&lt;TypeDeclaration&gt; types) {         setPackage(pakage);         setImports(imports);         setTypes(types);     }      public CompilationUnit(int beginLine, int beginColumn, int endLine, int endColumn, PackageDeclaration pakage, List&lt;ImportDeclaration&gt; imports, List&lt;TypeDeclaration&gt; types) {         super(beginLine, beginColumn, endLine, endColumn);         setPackage(pakage);         setImports(imports);         setTypes(types);     }      @Override     public &lt;R, A&gt; R accept(GenericVisitor&lt;R, A&gt; v, A arg) {         return v.visit(this, arg);     }      @Override     public &lt;A&gt; void accept(VoidVisitor&lt;A&gt; v, A arg) {         v.visit(this, arg);     }      /**      * Return a list containing all comments declared in this compilation unit.      * Including javadocs, line comments and block comments of all types,      * inner-classes and other members.&lt;br&gt;      * If there is no comment, &lt;code&gt;null&lt;/code&gt; is returned.      *       * @return list with all comments of this compilation unit or      *         &lt;code&gt;null&lt;/code&gt;      * @see JavadocComment      * @see com.github.javaparser.ast.comments.LineComment      * @see com.github.javaparser.ast.comments.BlockComment      */     public List&lt;Comment&gt; getComments() {         return this.getAllContainedComments();     }      /**      * Retrieves the list of imports declared in this compilation unit or      * &lt;code&gt;null&lt;/code&gt; if there is no import.      *       * @return the list of imports or &lt;code&gt;null&lt;/code&gt; if there is no import      */     public List&lt;ImportDeclaration&gt; getImports() {         return imports;     }      /**      * Retrieves the package declaration of this compilation unit.&lt;br&gt;      * If this compilation unit has no package declaration (default package),      * &lt;code&gt;null&lt;/code&gt; is returned.      *       * @return the package declaration or &lt;code&gt;null&lt;/code&gt;      */     public PackageDeclaration getPackage() {         return pakage;     }      /**      * Return the list of types declared in this compilation unit.&lt;br&gt;      * If there is no types declared, &lt;code&gt;null&lt;/code&gt; is returned.      *       * @return the list of types or &lt;code&gt;null&lt;/code&gt; null if there is no type      * @see AnnotationDeclaration      * @see ClassOrInterfaceDeclaration      * @see EmptyTypeDeclaration      * @see EnumDeclaration      */     public List&lt;TypeDeclaration&gt; getTypes() {         return types;     }      /**      * Sets the list of comments of this compilation unit.      *       * @param comments      *            the list of comments      */     public void setComments(List&lt;Comment&gt; comments) {         throw new RuntimeException(&quot;Not implemented!&quot;);     }      /**      * Sets the list of imports of this compilation unit. The list is initially      * &lt;code&gt;null&lt;/code&gt;.      *       * @param imports      *            the list of imports      */     public void setImports(List&lt;ImportDeclaration&gt; imports) {         this.imports = imports;         setAsParentNodeOf(this.imports);     }      /**      * Sets or clear the package declarations of this compilation unit.      *       * @param pakage      *            the pakage declaration to set or &lt;code&gt;null&lt;/code&gt; to default      *            package      */     public void setPackage(PackageDeclaration pakage) {         this.pakage = pakage;         setAsParentNodeOf(this.pakage);     }      /**      * Sets the list of types declared in this compilation unit.      *       * @param types      *            the lis of types      */     public void setTypes(List&lt;TypeDeclaration&gt; types) {         this.types = types;         setAsParentNodeOf(this.types);     } }} is not a class",1
"Unexpected exception, expected&lt;com.github.javaparser.symbolsolver.model.resolution.UnsolvedSymbolException&gt; but was&lt;java.lang.UnsupportedOperationException&gt;",1
"JavaParserClassDeclaration{wrappedNode=/**  * Abstract class for all nodes of the AST.  *  * Each Node can have one associated comment which describe it and  * a number of &quot;orphan comments&quot; which it contains but are not specifically  * associated to any element.  *   * @author Julio Vilmar Gesser  */ public abstract class Node implements Cloneable {      private int beginLine;      private int beginColumn;      private int endLine;      private int endColumn;      private Node parentNode;      private List&lt;Node&gt; childrenNodes = new LinkedList&lt;Node&gt;();      private List&lt;Comment&gt; orphanComments = new LinkedList&lt;Comment&gt;();      /**      * This attribute can store additional information from semantic analysis.      */     private Object data;      private Comment comment;      public Node() {     }      public Node(final int beginLine, final int beginColumn, final int endLine, final int endColumn) {         this.beginLine = beginLine;         this.beginColumn = beginColumn;         this.endLine = endLine;         this.endColumn = endColumn;     }      /**      * Accept method for visitor support.      *       * @param &lt;R&gt;      *            the type the return value of the visitor      * @param &lt;A&gt;      *            the type the argument passed to the visitor      * @param v      *            the visitor implementation      * @param arg      *            the argument passed to the visitor      * @return the result of the visit      */     public abstract &lt;R, A&gt; R accept(GenericVisitor&lt;R, A&gt; v, A arg);      /**      * Accept method for visitor support.      *       * @param &lt;A&gt;      *            the type the argument passed for the visitor      * @param v      *            the visitor implementation      * @param arg      *            any value relevant for the visitor      */     public abstract &lt;A&gt; void accept(VoidVisitor&lt;A&gt; v, A arg);      /**      * Return the begin column of this node.      *       * @return the begin column of this node      */     public final int getBeginColumn() {         return beginColumn;     }      /**      * Return the begin line of this node.      *       * @return the begin line of this node      */     public final int getBeginLine() {         return beginLine;     }      /**      * This is a comment associated with this node.      *      * @return comment property      */     public final Comment getComment() {         return comment;     }      /**      * Use this to retrieve additional information associated to this node.      *      * @return data property      */     public final Object getData() {         return data;     }      /**      * Return the end column of this node.      *       * @return the end column of this node      */     public final int getEndColumn() {         return endColumn;     }      /**      * Return the end line of this node.      *       * @return the end line of this node      */     public final int getEndLine() {         return endLine;     }      /**      * Sets the begin column of this node.      *       * @param beginColumn      *            the begin column of this node      */     public final void setBeginColumn(final int beginColumn) {         this.beginColumn = beginColumn;     }      /**      * Sets the begin line of this node.      *       * @param beginLine      *            the begin line of this node      */     public final void setBeginLine(final int beginLine) {         this.beginLine = beginLine;     }      /**      * Use this to store additional information to this node.      *      * @param comment to be set      */     public final void setComment(final Comment comment) {         if (comment != null &amp;&amp; (this instanceof Comment)) {             throw new RuntimeException(&quot;A comment can not be commented&quot;);         }         if (this.comment != null) {             this.comment.setCommentedNode(null);         }         this.comment = comment;         if (comment != null) {             this.comment.setCommentedNode(this);         }     }      /**      * Use this to store additional information to this node.      *      * @param data to be set      */     public final void setData(final Object data) {         this.data = data;     }      /**      * Sets the end column of this node.      *       * @param endColumn      *            the end column of this node      */     public final void setEndColumn(final int endColumn) {         this.endColumn = endColumn;     }      /**      * Sets the end line of this node.      *       * @param endLine      *            the end line of this node      */     public final void setEndLine(final int endLine) {         this.endLine = endLine;     }      /**      * Return the String representation of this node.      *       * @return the String representation of this node      */     @Override     public final String toString() {         final DumpVisitor visitor = new DumpVisitor();         accept(visitor, null);         return visitor.getSource();     }      public final String toStringWithoutComments() {         final DumpVisitor visitor = new DumpVisitor(false);         accept(visitor, null);         return visitor.getSource();     }      @Override     public final int hashCode() {         return toString().hashCode();     }      @Override     public boolean equals(final Object obj) {         if (obj == null || !(obj instanceof Node)) {             return false;         }         return EqualsVisitor.equals(this, (Node) obj);     }      @Override     public Node clone() {         return this.accept(new CloneVisitor(), null);     }      public Node getParentNode() {         return parentNode;     }      public List&lt;Node&gt; getChildrenNodes() {         return childrenNodes;     }      public boolean contains(Node other) {         if (getBeginLine() &gt; other.getBeginLine())             return false;         if (getBeginLine() == other.getBeginLine() &amp;&amp; getBeginColumn() &gt; other.getBeginColumn())             return false;         if (getEndLine() &lt; other.getEndLine())             return false;         if (getEndLine() == other.getEndLine() &amp;&amp; getEndColumn() &lt; other.getEndColumn())             return false;         return true;     }      public void addOrphanComment(Comment comment) {         orphanComments.add(comment);         comment.setParentNode(this);     }      /**      * This is a list of Comment which are inside the node and are not associated      * with any meaningful AST Node.      *      * For example, comments at the end of methods (immediately before the parenthesis)      * or at the end of CompilationUnit are orphan comments.      *      * When more than one comments preceed a statement, the one immediately preceeding it      * it is associated with the statements, while the others are &quot;orphan&quot;.      * @return all comments that cannot be attributed to a concept      */     public List&lt;Comment&gt; getOrphanComments() {         return orphanComments;     }      /**      * This is the list of Comment which are contained in the Node either because      * they are properly associated to one of its children or because they are floating      * around inside the Node      * @return all Comments within the node as a list      */     public List&lt;Comment&gt; getAllContainedComments() {         List&lt;Comment&gt; comments = new LinkedList&lt;Comment&gt;();         comments.addAll(getOrphanComments());         for (Node child : getChildrenNodes()) {             if (child.getComment() != null) {                 comments.add(child.getComment());             }             comments.addAll(child.getAllContainedComments());         }         return comments;     }      /**      * Assign a new parent to this node, removing it      * from the list of children of the previous parent, if any.      *      * @param parentNode node to be set as parent      */     public void setParentNode(Node parentNode) {         // remove from old parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.remove(this);         }         this.parentNode = parentNode;         // add to new parent, if any         if (this.parentNode != null) {             this.parentNode.childrenNodes.add(this);         }     }      protected void setAsParentNodeOf(List&lt;? extends Node&gt; childNodes) {         if (childNodes != null) {             Iterator&lt;? extends Node&gt; it = childNodes.iterator();             while (it.hasNext()) {                 Node current = it.next();                 current.setParentNode(this);             }         }     }      protected void setAsParentNodeOf(Node childNode) {         if (childNode != null) {             childNode.setParentNode(this);         }     }      public static final int ABSOLUTE_BEGIN_LINE = -1;      public static final int ABSOLUTE_END_LINE = -2;      public boolean isPositionedAfter(int line, int column) {         if (line == ABSOLUTE_BEGIN_LINE)             return true;         if (getBeginLine() &gt; line) {             return true;         } else if (getBeginLine() == line) {             return getBeginColumn() &gt; column;         } else {             return false;         }     }      public boolean isPositionedBefore(int line, int column) {         if (line == ABSOLUTE_END_LINE)             return true;         if (getEndLine() &lt; line) {             return true;         } else if (getEndLine() == line) {             return getEndColumn() &lt; column;         } else {             return false;         }     }      public boolean hasComment() {         return comment != null;     } }} is not a class",4
JavassistClassDeclaration {com.github.javaparser.ast.CompilationUnit} is not a class,1
Unsolved symbol : T,22
Unsolved symbol : A,30
"Error calculating the type of parameter arg of method call javadocComment.accept(this, arg)",4
No type named &#x27;Generics&#x27;found,8
No type named &#x27;MethodCalls&#x27;found,4
No type named &#x27;MyClass&#x27;found,10
Unsolved symbol : com.github.javaparser.ast.body.ConstructorDeclaration,48
Unsolved symbol : com.github.javaparser.ast.nodeTypes.NodeWithAnnotations,16
"Unexpected exception, expected&lt;java.lang.UnsupportedOperationException&gt; but was&lt;com.github.javaparser.symbolsolver.javaparsermodel.UnsolvedSymbolException&gt;",12
No type named &#x27;QualifiedNameTest&#x27;found,2
No type named &#x27;Foo&#x27;found,10
No type found,16
No type named &#x27;SomeCollection&#x27;found,12
com.github.javaparser.ast.body.ClassOrInterfaceDeclaration cannot be cast to com.github.javaparser.ast.nodeTypes.NodeWithName,124
No type named &#x27;AccessClassMemberThroughThis&#x27;found,4
No type named &#x27;LocalVariableInParent&#x27;found,10
Unsolved symbol : com.github.javaparser.ast.Modifier,16
No type named &#x27;Agenda&#x27;found,16
No type named &#x27;ClassExpression&#x27;found,2
No type named &#x27;TypeParamOnReturnType&#x27;found,8
No type named &#x27;ClassCast&#x27;found,4
No type named &#x27;ElementOfList&#x27;found,4
No type named &#x27;VoidVisitorAdapter&#x27;found,4
No type named &#x27;A&#x27;found,72
"Unexpected exception, expected&lt;com.github.javaparser.symbolsolver.model.declarations.MethodAmbiguityException&gt; but was&lt;java.lang.IllegalStateException&gt;",4
No type named &#x27;Navigator&#x27;found,34
No type named &#x27;ReferencesToField&#x27;found,2
No type named &#x27;ArrayAccess&#x27;found,2
No type named &#x27;OverloadedMethods&#x27;found,6
No type named &#x27;ReferenceToParameter&#x27;found,2
No type named &#x27;ReferencesToFieldExtendingClass&#x27;found,2
No type named &#x27;CA&#x27;found,4
Unsolved symbol : com.github.javaparser.ast.CompilationUnit,26
"Unexpected exception, expected&lt;com.github.javaparser.symbolsolver.model.resolution.UnsolvedSymbolException&gt; but was&lt;com.github.javaparser.symbolsolver.javaparsermodel.UnsolvedSymbolException&gt;",3
No type named &#x27;CB&#x27;found,2
Unsolved symbol : Assert,10
Unsolved symbol : System,28
No type named &#x27;SwitchOnEnum&#x27;found,2
No method with given name,65
No field with given name,9
com.github.javaparser.ast.body.EnumDeclaration cannot be cast to com.github.javaparser.ast.nodeTypes.NodeWithName,8
Unsolved symbol : Super,22
"Unexpected exception, expected&lt;com.github.javaparser.symbolsolver.model.declarations.MethodAmbiguityException&gt; but was&lt;com.github.javaparser.symbolsolver.javaparsermodel.UnsolvedSymbolException&gt;",2
Unsolved symbol : BlockStmt,2
Unsolved symbol : List,8
Unsolved symbol : NodeWithJavaDoc,24
Unsolved symbol : EnumSet,3
Unsolved symbol : DocumentableNode,4
"Unexpected exception, expected&lt;com.github.javaparser.symbolsolver.model.resolution.UnsolvedSymbolException&gt; but was&lt;java.lang.ClassCastException&gt;",2
Unsolved symbol : CA,1
"Unable to calculate the type of a parameter of a method call. Method call: foo(a), Parameter: a",2
Issur calculating the type of the scope of MethodCallExprContext{wrapped=persons.stream().map( p -&gt; p.toLowerCase())},3
Unsolved symbol in Solving EnumSet : EnumSet,1
"Unexpected exception, expected&lt;com.github.javaparser.symbolsolver.model.declarations.MethodAmbiguityException&gt; but was&lt;java.lang.ClassCastException&gt;",2
Unsolved symbol : CompilationUnit,3
Issur calculating the type of the scope of MethodCallExprContext{wrapped=cu.getTypes()},1
Unsolved symbol : Stream,1
Unsolved symbol : NameExpr,1
Error calculating the type of parameter in of method call streamToString(in),1
Unsolved symbol : ReferenceType,1
Unsolved symbol : VoidType,1
Unsolved symbol : ArrayInitializerExpr,1
Unsolved symbol : Integer,1
Unsolved symbol : NullLiteralExpr,1
Unsolved symbol : TypeExpr,1
Unsolved symbol : UnaryExpr,1
Unsolved symbol : ConditionalExpr,1
com.github.javaparser.Position cannot be cast to com.github.javaparser.ast.Node,1
com.github.javaparser.ast.type.PrimitiveType cannot be cast to com.github.javaparser.ast.type.ArrayType,6
"ArrayTypeUsage{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}} is not a Reference Type",1
java.lang.String java.lang.String[],1
String index out of range: 4,1
TypeParameter,1
ArrayCreationExpr,1
ArrayCreationLevel,1
LongLiteralExpr,1
EmptyMemberDeclaration,1
InitializerDeclaration,1
NormalAnnotationExpr,1
ArrayInitializerExpr,1
EnumDeclaration,1
EnumConstantDeclaration,1
Unable to get list value for MEMBERS from m(1) {      @Override     void mm() {     } }  (class: EnumConstantDeclaration),1
ArrayAccessExpr,1
SuperExpr,1
LocalClassDeclarationStmt,1
ExplicitConstructorInvocationStmt,1
AssertStmt,1
LabeledStmt,1
EmptyStmt,1
SwitchStmt,1
SwitchEntryStmt,1
BreakStmt,1
com.github.javaparser.ast.type.ClassOrInterfaceType cannot be cast to com.github.javaparser.ast.NodeList,1
ConditionalExpr,2
ContinueStmt,1
DoStmt,1
TryStmt,1
CatchClause,1
UnionType,1
com.github.javaparser.ast.NodeList cannot be cast to com.github.javaparser.ast.Node,1
"The CSM should include support for these classes: AnnotationExpr, BlockComment, BodyDeclaration, CallableDeclaration, Comment, Expression, IntersectionType, JavadocComment, LineComment, LiteralExpr, LiteralStringValueExpr, MemberValuePair, Node, ReferenceType, SingleMemberAnnotationExpr, Statement, TypeDeclaration, Type",9
"The CSM should include support for these classes: BlockComment, JavadocComment, LineComment",9
"The CSM should include support for these classes: ModuleDeclaration, ModuleExportsStmt, ModuleOpensStmt, ModuleProvidesStmt, ModuleRequiresStmt, ModuleUsesStmt",9
"Unable to get value for NAME from provides X.Y with Z1.Z2, Z3.Z4;  (ModuleProvidesStmt)",1
"(line 1,col 10) Parse error. Found &quot;@&quot;, expected one of  &quot;boolean&quot; &quot;byte&quot; &quot;char&quot; &quot;double&quot; &quot;exports&quot; &quot;float&quot; &quot;int&quot; &quot;long&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;short&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;void&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9945)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9801)   com.github.javaparser.GeneratedJavaParser.ResultType(GeneratedJavaParser.java:2142)   com.github.javaparser.GeneratedJavaParser.MethodDeclaration(GeneratedJavaParser.java:1294)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceBodyDeclaration(GeneratedJavaParser.java:1033)   com.github.javaparser.ParseStart.lambda$static$0(ParseStart.java:54)   com.github.javaparser.JavaParser.parse(JavaParser.java:103)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:362)   com.github.javaparser.JavaParser.parseClassBodyDeclaration(JavaParser.java:424)   com.github.javaparser.ast.body.MethodDeclarationTest.annotationsAllowedAfterGenericsAndBeforeReturnType(MethodDeclarationTest.java:9)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"NodeText: NodeText{[ChildTextElement{package org.javaparser.lexicalpreservation.examples;  }, ChildTextElement{// Hey, this is a comment }, TokenTextElement(3) { }, TokenTextElement(3) { }, ChildTextElement{// Another one }, TokenTextElement(3) { }, ChildTextElement{class A { }}]}. Difference: Difference{[Added{child(PackageDeclaration)}, Kept{child(ClassOrInterfaceDeclaration)}, Kept{token( )}]} ChildTextElement{class A { }}",1
Override,1
"(line 1,col 1) Modules are not supported. ",4
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:79)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addPrivateField(NodeWithMembers.java:120)   com.github.javaparser.builders.FieldDeclarationBuildersTest.testCreateGetterInEnum(FieldDeclarationBuildersTest.java:95)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:79)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addPrivateField(NodeWithMembers.java:120)   com.github.javaparser.builders.FieldDeclarationBuildersTest.testCreateSetterInAClass(FieldDeclarationBuildersTest.java:81)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:79)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addPrivateField(NodeWithMembers.java:120)   com.github.javaparser.builders.FieldDeclarationBuildersTest.testCreateSetterInEnum(FieldDeclarationBuildersTest.java:108)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Unexpected exception, expected&lt;java.lang.IllegalStateException&gt; but was&lt;com.github.javaparser.ParseProblemException&gt;",2
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:79)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addPrivateField(NodeWithMembers.java:120)   com.github.javaparser.builders.FieldDeclarationBuildersTest.testCreateGetterInAClass(FieldDeclarationBuildersTest.java:68)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:71)   com.github.javaparser.wiki_samples.MethodChanger_1$MethodChangerVisitor.visit(MethodChanger_1.java:54)   com.github.javaparser.wiki_samples.MethodChanger_1$MethodChangerVisitor.visit(MethodChanger_1.java:47)   com.github.javaparser.ast.body.MethodDeclaration.accept(MethodDeclaration.java:103)   com.github.javaparser.ast.visitor.VoidVisitorAdapter.lambda$visit$29(VoidVisitorAdapter.java:150)   java.util.ArrayList.forEach(ArrayList.java:1259)   com.github.javaparser.ast.NodeList.forEach(NodeList.java:213)   com.github.javaparser.ast.visitor.VoidVisitorAdapter.visit(VoidVisitorAdapter.java:150)   com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.accept(ClassOrInterfaceDeclaration.java:93)   com.github.javaparser.ast.visitor.VoidVisitorAdapter.lambda$visit$40(VoidVisitorAdapter.java:170)   java.util.ArrayList.forEach(ArrayList.java:1259)   com.github.javaparser.ast.NodeList.forEach(NodeList.java:213)   com.github.javaparser.ast.visitor.VoidVisitorAdapter.visit(VoidVisitorAdapter.java:170)   com.github.javaparser.wiki_samples.MethodChanger_1.main(MethodChanger_1.java:38)   com.github.javaparser.wiki_samples.ChangingMethodsFromAClassWithAVisitorTest.printingTheCompilationUnitToSystemOutput(ChangingMethodsFromAClassWithAVisitorTest.java:30)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:61)   com.github.javaparser.builders.NodeWithMembersBuildersTest.testGetMethodsWithParameterTypes(NodeWithMembersBuildersTest.java:100)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:79)   com.github.javaparser.builders.NodeWithMembersBuildersTest.testAddField(NodeWithMembersBuildersTest.java:42)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:79)   com.github.javaparser.builders.NodeWithMembersBuildersTest.testGetFieldWithName(NodeWithMembersBuildersTest.java:117)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:79)   com.github.javaparser.builders.NodeWithMembersBuildersTest.testGetFields(NodeWithMembersBuildersTest.java:125)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:61)   com.github.javaparser.builders.NodeWithMembersBuildersTest.testGetMethods(NodeWithMembersBuildersTest.java:88)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:61)   com.github.javaparser.builders.NodeWithMembersBuildersTest.testGetMethodsWithName(NodeWithMembersBuildersTest.java:78)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.printer.lexicalpreservation.transformations.ast.body.ClassOrInterfaceDeclarationTransformationsTest.addingField(ClassOrInterfaceDeclarationTransformationsTest.java:178)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:71)   com.github.javaparser.printer.lexicalpreservation.TransformationsTest.exampleParam1(TransformationsTest.java:108)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;char&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:71)   com.github.javaparser.printer.lexicalpreservation.TransformationsTest.exampleParam2(TransformationsTest.java:117)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinterTest.printASuperSimpleClassWithAFieldAdded(LexicalPreservingPrinterTest.java:266)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;float&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:71)   com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinterTest.printASimpleMethodAddingAParameterToAMethodWithOneParameter(LexicalPreservingPrinterTest.java:316)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;float&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:71)   com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinterTest.printASimpleMethodAddingAParameterToAMethodWithZeroParameters(LexicalPreservingPrinterTest.java:306)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.NodeTest.registerWithJustNodeMode(NodeTest.java:103)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.NodeTest.registerWithNodeAndExistingDescendantsMode(NodeTest.java:136)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithMembers.addField(NodeWithMembers.java:91)   com.github.javaparser.ast.NodeTest.registerWithSelfPropagatingMode(NodeTest.java:173)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addAndGetParameter(NodeWithParameters.java:86)   com.github.javaparser.builders.NodeWithParametersBuildersTest.testGetParamByName(NodeWithParametersBuildersTest.java:66)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addAndGetParameter(NodeWithParameters.java:86)   com.github.javaparser.builders.NodeWithParametersBuildersTest.testGetParamByType(NodeWithParametersBuildersTest.java:73)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"(line 0,col 0) Parse error. Found &quot;int&quot;, expected one of  &quot;exports&quot; &quot;module&quot; &quot;open&quot; &quot;opens&quot; &quot;provides&quot; &quot;requires&quot; &quot;to&quot; &quot;transitive&quot; &quot;uses&quot; &quot;with&quot; &lt;IDENTIFIER&gt; Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:9874)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:9730)   com.github.javaparser.GeneratedJavaParser.Identifier(GeneratedJavaParser.java:2060)   com.github.javaparser.GeneratedJavaParser.SimpleName(GeneratedJavaParser.java:2007)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceType(GeneratedJavaParser.java:1739)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:386)   com.github.javaparser.JavaParser.parseClassOrInterfaceType(JavaParser.java:474)   com.github.javaparser.ast.nodeTypes.NodeWithParameters.addParameter(NodeWithParameters.java:61)   com.github.javaparser.builders.NodeWithParametersBuildersTest.testAddParameter(NodeWithParametersBuildersTest.java:53)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)   org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
com.github.javaparser.ast.expr.VariableDeclarationExpr cannot be cast to com.github.javaparser.ast.body.FieldDeclaration,1
I could not find child &#x27;com.github.javaparser.printer.lexicalpreservation.TextElementMatchers$$Lambda$182/1197430386@1a1c21b4&#x27; from position 0,1
removed child(MarkerAnnotationExpr) vs TokenTextElement(73) {protected},2
"I could not find child &#x27;(c1, c2) -&gt; c1.getKey().compareTo(c2.getKey())&#x27; in parent &#x27;(Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey())&#x27;. parentNodeText: NodeText{[ChildTextElement{Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable}]}",3
kept token(() vs ChildTextElement{c1},2
"Unexpected exception, expected&lt;java.lang.AssertionError&gt; but was&lt;com.github.javaparser.ParseProblemException&gt;",5
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 8.  Was expecting one of:      &quot;,&quot;     &quot;=&quot;     &quot;@&quot;     &quot;[&quot;     &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.VariableDeclarationExpressionParseStart(GeneratedJavaParser.java:5617)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseVariableDeclarationExpr(JavaParser.java:450)   com.github.javaparser.ast.nodeTypes.NodeWithVariablesTest.getCommonTypeWorksForNormalVariables(NodeWithVariablesTest.java:35)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 8.  Was expecting one of:      &quot;,&quot;     &quot;=&quot;     &quot;@&quot;     &quot;[&quot;     &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.VariableDeclarationExpressionParseStart(GeneratedJavaParser.java:5617)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseVariableDeclarationExpr(JavaParser.java:450)   com.github.javaparser.ast.nodeTypes.NodeWithVariablesTest.getElementTypeWorksForNormalVariables(NodeWithVariablesTest.java:65)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 14.  Was expecting one of:      &quot;,&quot;     &quot;=&quot;     &quot;@&quot;     &quot;[&quot;     &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.VariableDeclarationExpressionParseStart(GeneratedJavaParser.java:5617)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseVariableDeclarationExpr(JavaParser.java:450)   com.github.javaparser.ast.nodeTypes.NodeWithVariablesTest.getElementTypeIsOkayWithArrayDifferences(NodeWithVariablesTest.java:77)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 12.  Was expecting one of:      &quot;,&quot;     &quot;=&quot;     &quot;@&quot;     &quot;[&quot;     &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.VariableDeclarationExpressionParseStart(GeneratedJavaParser.java:5617)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseVariableDeclarationExpr(JavaParser.java:450)   com.github.javaparser.ast.nodeTypes.NodeWithVariablesTest.getCommonTypeWorksForArrayTypes(NodeWithVariablesTest.java:41)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 12.  Was expecting one of:      &quot;,&quot;     &quot;=&quot;     &quot;@&quot;     &quot;[&quot;     &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.VariableDeclarationExpressionParseStart(GeneratedJavaParser.java:5617)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseVariableDeclarationExpr(JavaParser.java:450)   com.github.javaparser.ast.nodeTypes.NodeWithVariablesTest.getElementTypeWorksForArrayTypes(NodeWithVariablesTest.java:71)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 30.  Was expecting:      &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceBodyDeclarationParseStart(GeneratedJavaParser.java:5599)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseBodyDeclaration(JavaParser.java:416)   com.github.javaparser.ast.type.ArrayTypeTest.getParameterWithArrays(ArrayTypeTest.java:102)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 25.  Was expecting:      &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceBodyDeclarationParseStart(GeneratedJavaParser.java:5599)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseBodyDeclaration(JavaParser.java:416)   com.github.javaparser.ast.type.ArrayTypeTest.setParameterWithArrays(ArrayTypeTest.java:146)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 24.  Was expecting:      &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceBodyDeclarationParseStart(GeneratedJavaParser.java:5599)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseBodyDeclaration(JavaParser.java:416)   com.github.javaparser.ast.type.ArrayTypeTest.getMethodDeclarationWithArrays(ArrayTypeTest.java:87)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 30.  Was expecting:      &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceBodyDeclarationParseStart(GeneratedJavaParser.java:5599)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseBodyDeclaration(JavaParser.java:416)   com.github.javaparser.ast.type.TypeConstructionTest.getParameterWithArrays(TypeConstructionTest.java:100)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 25.  Was expecting:      &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceBodyDeclarationParseStart(GeneratedJavaParser.java:5599)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseBodyDeclaration(JavaParser.java:416)   com.github.javaparser.ast.type.TypeConstructionTest.setParameterWithArrays(TypeConstructionTest.java:144)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 24.  Was expecting:      &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.ClassOrInterfaceBodyDeclarationParseStart(GeneratedJavaParser.java:5599)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseBodyDeclaration(JavaParser.java:416)   com.github.javaparser.ast.type.TypeConstructionTest.getMethodDeclarationWithArrays(TypeConstructionTest.java:85)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Encountered unexpected token: &quot;;&quot; &quot;;&quot;     at line 1, column 6.  Was expecting one of:      &quot;,&quot;     &quot;=&quot;     &quot;@&quot;     &quot;[&quot;     &lt;EOF&gt;  Problem stacktrace :    com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10189)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10045)   com.github.javaparser.GeneratedJavaParser.VariableDeclarationExpressionParseStart(GeneratedJavaParser.java:5617)   com.github.javaparser.JavaParser.parse(JavaParser.java:123)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:323)   com.github.javaparser.JavaParser.parseVariableDeclarationExpr(JavaParser.java:450)   com.github.javaparser.ast.type.TypeTest.typeAsString(TypeTest.java:47)   com.github.javaparser.ast.type.TypeTest.asString(TypeTest.java:20)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
The CSM should include support for these classes: ReceiverParameter,318
"Lexical error at line 1, column 4.  Encountered: &quot;\\&quot; (92), after : &quot;&quot; Problem stacktrace :    com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:2694)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10107)   com.github.javaparser.GeneratedJavaParser.SimpleNameParseStart(GeneratedJavaParser.java:5632)   com.github.javaparser.JavaParser.parse(JavaParser.java:133)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:339)   com.github.javaparser.JavaParser.parseSimpleName(JavaParser.java:511)   com.github.javaparser.ast.expr.SimpleNameTest.mayContainUnicodeEscapes(SimpleNameTest.java:48)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
"Lexical error at line 1, column 4.  Encountered: &quot;\\&quot; (92), after : &quot;&quot; Problem stacktrace :    com.github.javaparser.GeneratedJavaParserTokenManager.getNextToken(GeneratedJavaParserTokenManager.java:2704)   com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10111)   com.github.javaparser.GeneratedJavaParser.SimpleNameParseStart(GeneratedJavaParser.java:5636)   com.github.javaparser.JavaParser.parse(JavaParser.java:133)   com.github.javaparser.JavaParser.simplifiedParse(JavaParser.java:339)   com.github.javaparser.JavaParser.parseSimpleName(JavaParser.java:511)   com.github.javaparser.ast.expr.SimpleNameTest.mayContainUnicodeEscapes(SimpleNameTest.java:48)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)   org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)   org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)   org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)   org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)   org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)   org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)   org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)   org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)   org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)   org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)   org.junit.runners.ParentRunner.run(ParentRunner.java:363)   org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)   org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)   org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)   sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   java.lang.reflect.Method.invoke(Method.java:498)   org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)   org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)   org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)   org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)   org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75) ",1
kept token(}) vs ChildTextElement{public void writeExternal() { }},1
"kept child(ClassOrInterfaceType) vs &quot;String&quot;   &lt;89&gt;   (line 2,col 10)-(line 2,col 15)",1
I cannot adapt the path /home/bugs/projects/javaparser/java-symbol-solver-testing/src/test/resources/javassist_symbols/included_jar/included_jar.jar,15
kept token(}) vs ChildTextElement{// comment },1
Unsolved symbol : InnerClass,1
Attribute &#x27;operator&#x27; does not corresponding to any expected value. Text: AND,1
1,2
CsmIndent,1
Unsolved symbol : com.github.javaparser.FooClass,2
Unsolved symbol in foo.bar.AnInterface.ListChangeType.ADDITION : foo.bar.AnInterface.ListChangeType,49
Unsolved symbol in AnInterface.ListChangeType.ADDITION : AnInterface.ListChangeType,40
Unsolved symbol in BinaryExpr.Operator.OR : BinaryExpr.Operator,82
Unsolved symbol in foo.bar.BinaryExpr.Operator.AND : foo.bar.BinaryExpr.Operator,71
Unable to classify category of name contained in NameExpr,55
Unable to classify category of name contained in FieldAccessExpr,31
Unable to classify category of name contained in MethodCallExpr,5
Unable to classify category of name contained in Name,1
Unable to classify category of name contained in ConstructorDeclaration,1
Unable to classify category of name contained in ImportDeclaration,27
Unable to classify category of name contained in ClassOrInterfaceType,20
"Unsolved symbol in items.apply(Transforms.of(new DoFn&lt;Integer, Long&gt;() {
})) : items",2
Unsolved symbol in items.apply(Transforms.of(new MyFn2())) : items,2
"Error calculating the type of parameter i -&gt; {
    int irrelevant;
    return addPerson(&quot;&quot;);
} of method call persons.stream().parallel().map(i -&gt; {
    int irrelevant;
    return addPerson(&quot;&quot;);
})",2
Error calculating the type of parameter p -&gt; p.toLowerCase() of method call persons.stream().map(p -&gt; p.toLowerCase()),4
"Error calculating the type of parameter i -&gt; {
    return addPerson(&quot;&quot;);
} of method call persons.stream().parallel().map(i -&gt; {
    return addPerson(&quot;&quot;);
})",2
Unsolved symbol in persons.stream().map(p -&gt; p.toLowerCase()) : persons.stream(),2
"Unsolved symbol in persons.stream().forEach(p -&gt; {
    System.out.println(p);
}) : persons.stream()",2
"Error calculating the type of parameter n2 of method call n1.accept(this, n2)",4
Unsolved symbol in cu.getTypes() : cu,2
Error calculating the type of parameter (t) -&gt; t.getName().equals(name) of method call cu.getTypes().stream().filter((t) -&gt; t.getName().equals(name)),6
Unsolved symbol in cu.getTypes().stream() : cu.getTypes(),2
Unsolved symbol in cu.getTypes().stream().filter((t) -&gt; t.getName().equals(name)) : cu.getTypes().stream(),2
Unsolved symbol in array[0].trim() : array[0],2
Unsolved symbol in sc : Solving sc,1
Unsolved symbol in e : Solving e,2
Method &#x27;getSelf&#x27; cannot be resolved in context getSelf() (line: 19) MethodCallExprContext{wrapped=getSelf()}. Parameter types: [],1
Method &#x27;getSelf&#x27; cannot be resolved in context getSelf() (line: 24) MethodCallExprContext{wrapped=getSelf()}. Parameter types: [],1
Unsolved symbol in s : Solving s,5
Unsolved symbol in a : Solving a,1
"Method &#x27;foobar&#x27; cannot be resolved in context foobar(&quot;a&quot;) (line: 34) MethodCallExprContext{wrapped=foobar(&quot;a&quot;)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]",1
Unsolved symbol : We are unable to find the value declaration corresponding to foo,1
"Method &#x27;test&#x27; cannot be resolved in context test((x, y) -&gt; String.valueOf(func(x, y))) (line: 33) MethodCallExprContext{wrapped=test((x, y) -&gt; String.valueOf(func(x, y)))}. Parameter types: [ReferenceType{java.util.function.BiFunction, typeParametersMap=TypeParametersMap{nameToValue={java.util.function.BiFunction.U=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.function.BiFunction.R=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.function.BiFunction.T=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]",1
Unsolved symbol in persons : Solving persons,2
Unsolved symbol in n1 : Solving n1,1
"Method &#x27;callee&#x27; cannot be resolved in context callee(&quot;test&quot;) (line: 41) MethodCallExprContext{wrapped=callee(&quot;test&quot;)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]",1
"Method &#x27;foo&#x27; cannot be resolved in context foo(children, commentsToAttribute) (line: 17) MethodCallExprContext{wrapped=foo(children, commentsToAttribute)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{Comment, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]",1
Unsolved symbol in clazz : Solving clazz,2
Unsolved symbol in cu : Solving cu,3
"Method &#x27;overloaded&#x27; cannot be resolved in context overloaded(o) (line: 25) MethodCallExprContext{wrapped=overloaded(o)}. Parameter types: [ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}]",1
Method &#x27;overloaded&#x27; cannot be resolved in context overloaded(null) (line: 15) MethodCallExprContext{wrapped=overloaded(null)}. Parameter types: [com.github.javaparser.symbolsolver.model.typesystem.NullType@4020788f],1
"Method &#x27;overloaded&#x27; cannot be resolved in context overloaded(s) (line: 20) MethodCallExprContext{wrapped=overloaded(s)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]",1
Method &#x27;callAnnonClassInnerMethod&#x27; cannot be resolved in context callAnnonClassInnerMethod() (line: 41) MethodCallExprContext{wrapped=callAnnonClassInnerMethod()}. Parameter types: [],1
Unsolved symbol in c : Solving c,1
CorrespondingDeclaration not available for unsolved symbol.,4
Unable to classify role of name contained in ClassOrInterfaceType,1
Unable to classify role of name contained in VariableDeclarator,5
Unable to classify role of name contained in ConstructorDeclaration,2
Unable to classify role of name contained in ReceiverParameter,1
Unable to classify role of name contained in MemberValuePair,1
Unable to classify role of name contained in ArrayAccessExpr,1
Unable to classify role of name contained in AssignExpr,1
Unable to classify role of name contained in ThisExpr,1
Unable to classify role of name contained in Parameter,3
Unable to classify role of name contained in ClassOrInterfaceDeclaration,2
Unable to classify role of name contained in SuperExpr,3
Unable to classify role of name contained in TypeExpr,1
Unable to classify role of name contained in AnnotationMemberDeclaration,2
Unable to classify role of name contained in MethodCallExpr,2
Unable to classify role of name contained in ModuleExportsStmt,2
Unable to classify role of name contained in MethodDeclaration,2
Unable to classify role of name contained in ClassExpr,1
Unable to classify role of name contained in CastExpr,1
Unable to classify role of name contained in ModuleOpensStmt,3
Unable to classify role of name contained in ModuleRequiresStmt,1
Unable to classify role of name contained in ModuleUsesStmt,1
Unable to classify role of name contained in UnaryExpr,1
Unable to classify role of name contained in InstanceOfExpr,1
Unable to classify role of name contained in ExplicitConstructorInvocationStmt,1
Unable to classify role of name contained in ArrayCreationExpr,1
Unable to classify role of name contained in TryStmt,1
Unable to classify role of name contained in ModuleProvidesStmt,1
Unable to classify role of name contained in ObjectCreationExpr,1
com.google.common.util.concurrent.ExecutionError: java.lang.AssertionError: A reference was unexpectedly null.,1
com.google.common.util.concurrent.ExecutionError: com.google.common.util.concurrent.ExecutionError: java.lang.AssertionError: A reference was unexpectedly null.,2
Unsolved symbol : E3,2
Unsolved symbol : NodeList,125
"Unexpected exception, expected&lt;java.lang.UnsupportedOperationException&gt; but was&lt;java.lang.ClassCastException&gt;",14
com.github.javaparser.symbolsolver.reflectionmodel.ReflectionClassDeclaration cannot be cast to com.github.javaparser.symbolsolver.reflectionmodel.ReflectionEnumDeclaration,77
com.github.javaparser.ast.body.EnumDeclaration cannot be cast to com.github.javaparser.ast.body.ClassOrInterfaceDeclaration,1
Unsolved symbol : We are unable to find the constructor declaration corresponding to super(i);,1
Unsolved symbol : byte[],1
com.github.javaparser.ast.body.FieldDeclaration cannot be cast to com.github.javaparser.ast.body.ConstructorDeclaration,7
No data of this type found. Use containsData to check for this first.,2
CsmChild child(Modifier),44
"kept child(SimpleName) vs &quot;(&quot;   &lt;92&gt;   (line 3,col 23)-(line 3,col 23)",14
"removed child(ClassOrInterfaceType) vs &quot;String&quot;   &lt;89&gt;   (line 1,col 11)-(line 1,col 16)",5
-1,1
Expected 0 in text but found 1,2
Expected 2 in text but found 1,2
Expected 3 in text but found 2,6
Expected 3 in text but found 5,2
&quot;int&quot;   &lt;38&gt;   (?)-(?),2
removed token(10) vs ChildTextElement{10},1
removed token(a) vs ChildTextElement{a},1
"for (int i : myList) {
    body();
} is not an ForEachStmt",1
"(line 4,col 5) Only one label allowed in a switch-case.
",3
"(line 265,col 5) Only one label allowed in a switch-case.
",3
"(line 1,col 18) Switch expressions are not supported.
(line 2,col 5) Only one label allowed in a switch-case.
(line 4,col 5) Only one label allowed in a switch-case.
",3
"(line 1,col 12) Switch expressions are not supported.
(line 4,col 5) Only one label allowed in a switch-case.
",3
"(line 1,col 9) Switch expressions are not supported.
(line 4,col 5) Only one label allowed in a switch-case.
",3
"(line 1,col 14) Switch expressions are not supported.
(line 6,col 5) Only one label allowed in a switch-case.
",1
"(line 1,col 1) Switch expressions are not supported.
(line 1,col 1) Switch expressions are not supported.
",3
"(line 1,col 18) Switch expressions are not supported.
(line 2,col 5) Only one label allowed in a switch-case.
(line 2,col 5) Only &#x27;int&#x27;s, enums, and strings in switch statements are supported.
(line 4,col 5) Only &#x27;int&#x27;s, enums, and strings in switch statements are supported.
",3
"(line 211,col 13) Only one label allowed in a switch-case.
",3
"(line 239,col 17) Only one label allowed in a switch-case.
",3
"(line 235,col 17) Only one label allowed in a switch-case.
",3
"(line 1,col 14) Switch expressions are not supported.
(line 3,col 9) Only labels allowed in break statements.
(line 5,col 9) Only labels allowed in break statements.
(line 6,col 5) Only one label allowed in a switch-case.
(line 8,col 9) Only labels allowed in break statements.
",2
"(line 1,col 1) Only labels allowed in break statements.
(line 1,col 1) Only labels allowed in break statements.
",2
"kept child(ClassOrInterfaceType) vs &quot;String&quot;   &lt;89&gt;   (line 1,col 18)-(line 1,col 23)",2
Unable to get value for CLASS_NAME from this (ThisExpr),4
"kept child(ClassOrInterfaceType) vs &quot;String&quot;   &lt;93&gt;   (line 1,col 18)-(line 1,col 23)",1
Unsolved symbol : We are unable to find the constructor declaration corresponding to new Test().new InnerTest(),1
"Unable to calculate the type of a parameter of a method call. Method call: new InnerClass(~8), Parameter: ~8",1
Method &#x27;hashCode&#x27; cannot be resolved in context key.hashCode() (line: 4) MethodCallExprContext{wrapped=key.hashCode()}. Parameter types: [],1
"Index: 3, Size: 3",2
Method &#x27;getView&#x27; cannot be resolved in context b3.getView().getView() (line: 29) MethodCallExprContext{wrapped=b3.getView().getView()}. Parameter types: [],2
Unsolved symbol : We are unable to find the method declaration corresponding to b3.getView().getView(),2
"Index: 0, Size: 0",6
Unsolved symbol : We are unable to find the constructor declaration corresponding to super();,2
"Parse error. Found &quot;{&quot;, expected one of  &quot;;&quot; &quot;@&quot; &quot;\u001a&quot; &quot;abstract&quot; &quot;class&quot; &quot;default&quot; &quot;enum&quot; &quot;final&quot; &quot;import&quot; &quot;interface&quot; &quot;module&quot; &quot;native&quot; &quot;open&quot; &quot;private&quot; &quot;protected&quot; &quot;public&quot; &quot;static&quot; &quot;strictfp&quot; &quot;synchronized&quot; &quot;transient&quot; &quot;transitive&quot; &quot;volatile&quot; &lt;EOF&gt;
Problem stacktrace : 
  com.github.javaparser.GeneratedJavaParser.generateParseException(GeneratedJavaParser.java:10667)
  com.github.javaparser.GeneratedJavaParser.jj_consume_token(GeneratedJavaParser.java:10526)
  com.github.javaparser.GeneratedJavaParser.CompilationUnit(GeneratedJavaParser.java:201)
  com.github.javaparser.JavaParser.parse(JavaParser.java:123)
  com.github.javaparser.JavaParser.parse(JavaParser.java:305)
  com.github.javaparser.StaticJavaParser.parse(StaticJavaParser.java:229)
  com.github.javaparser.printer.PrettyPrinterTest.prettyPrintField(PrettyPrinterTest.java:48)
  com.github.javaparser.printer.PrettyPrinterTest.print545(PrettyPrinterTest.java:62)
  sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
  sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
  sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
  java.lang.reflect.Method.invoke(Method.java:498)
  org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:675)
  org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
  org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:125)
  org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:132)
  org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:124)
  org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:74)
  org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
  org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
  org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:104)
  org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:62)
  org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:43)
  org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:35)
  org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
  org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
  org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:202)
  org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:198)
  org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135)
  org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:69)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)
  org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
  org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
  org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
  java.util.ArrayList.forEach(ArrayList.java:1259)
  org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
  org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
  org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
  org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
  java.util.ArrayList.forEach(ArrayList.java:1259)
  org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
  org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
  org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
  org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
  org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
  org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
  org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
  org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
  org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)
  org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)
  org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)
  org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)
  org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)
  org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:142)
  org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:117)
  org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384)
  org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345)
  org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126)
  org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418)
",2
maximum size must not be negative,356
